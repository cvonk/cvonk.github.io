{"id":30818,"date":"2015-10-14T18:43:00","date_gmt":"2015-10-15T01:43:00","guid":{"rendered":"https:\/\/coertvonk.com\/?p=30818"},"modified":"2022-04-29T17:51:23","modified_gmt":"2022-04-30T00:51:23","slug":"byte-exchange-with-a-fpga-as-slave","status":"publish","type":"post","link":"http:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818","title":{"rendered":"Byte protocol on FPGA"},"content":{"rendered":"<p>\r\n    Implements the SPI byte protocol on a FPGA.  Enables the exchange bytes with the Arduino.. Written in Verilog HDL. This page concludes the second part of <a href=\"\/category\/math-talk\">Math Talk<\/a>. It shows an implementation of the<a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/bytes-exchange-protocol-30814\"> SPI protocol<\/a> on a Field Programmable Gate Array (FPGA).\r\n<\/p>\r\n\r\n<h2 style=\"counter-reset: h2 4 h3\">\r\n    Byte Exchange with a FPGA as Slave\r\n<\/h2>\r\n\r\n<p>\r\n    Implementing the SPI Slave on an FPGA is like old school digital electronics. My key takeaway is to think hardware, not programming. Implementing the <a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/bytes-exchange-protocol-30814\">SPI protocol<\/a> on a FPGA is fairly straightforward for as long as we use a directly clocked sequential circuit while preventing clock domain crossings.\r\n<\/p>\r\n\r\n<h3>\r\n    Sequential circuit\r\n<\/h3>\r\n<p>\r\n    In real life, two signals going to a single gate will not arrive there at the same time due to wire delays. This causes the output to momentarily have an incorrect value. The problem compounds as the signal travels through more gates and wires.\r\n<\/p>\r\n<p>\r\n    In <a href=\"\/category\/hw\/building-math-circuits\">Building Math Circuits<\/a> we created elementary math operations using combinatorial circuits. That was OK, because we didn&#8217;t care about such output <em>glitches<\/em> caused by the input signals propagating to the outputs. From a demonstrator&#8217;s point of view it even made it more interesting. Talking to a real device, such as a SPI master is different, because it requires the outputs to be stable at certain times.\r\n\r\n    <div class=\"align-center\">\r\n        <div class=\"flow-container\">\r\n            <figure>\r\n                <a href=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-register-copy.svg\"><img  title=\"\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-register-copy.svg\" alt=\"\" width=\"200\" class=\"alignnone size-large wp-image-32823\" \/><\/a>\r\n                <figcaption>\r\n                    D flip-flop\r\n                <\/figcaption>\r\n            <\/figure>\r\n        <\/div>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The solution is to introduce a clock signal, and store the signals in a flip-flop (registers) at the rising edge of that clock signal. We then only need to ensure that the longest delay from one flip-flop to the next is less that the clock period. This greatly simplifies the design process, at the cost of introducing some delay.\r\n<\/p>\r\n<p>\r\n    The Verilog description shown below is an example of a synchronous design. It clocks signal <code>s<\/code> at the rising edge of the clock signal <code>sysClk<\/code> into register <code>r<\/code>.\r\n\r\n    wire in;\r\n    reg out;\r\n    always @(posedge sysClk)\r\n    out <= in;[\/code]\r\n<\/p>\r\n\r\n<h3>\r\n    Clock domain\r\n<\/h3>\r\n<p>\r\n    Field programmable gate arrays thrive on synchronous designs, but they don&#8217;t do well with clock signals that are asynchronous with its system clock. In particular, constructs such as <code>@(posedge SCLK)<\/code>, will give the synthesizer the impression that <em>SCLK<\/em> is a clock signal and cause it to reserve special low-skew clock buffers, causing the fitter to run out of such buffers, resort to use general routing for the real system clock signal.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n            <a href=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-sync-copy.svg\"><img src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-sync-copy.svg\" alt=\"\" width=\"450\" class=\"alignnone size-large wp-image-32819\" \/><\/a>\r\n            <figcaption>\r\n                Two-stage shift register\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    We also need to avoid transferring data from a flip-flop driven by one clock to a flip-flop driven by another clock. This is called a <em>clock domain crossing<\/em> and might manifest itself in <em>metastability<\/em>, data loss or incoherence [EE Times]. We prevent clock domain crossings, by synchronizing the input signals to the FPGA clock using a traditional two-stage shift register as illustrated above.\r\n    <ol>\r\n            <li>The first flip-flop, creates a synchronous version of the inputs by clocking it with the system clock. The input signal could change within the flip-flop&#8217;s <em>setup and hold times<\/em> and may take longer than a system clock cycle to settle to a stable value (metastability). That&#8217;s why it is ran through a second flip-flop.<\/li>\r\n            <li>The second flip-flop, makes it is very unlikely that this metastability propagates to the output.<\/li>\r\n    <\/ol>\r\n<\/p>\r\n<p>\r\n    Adding a third flip-flop gives us access to the previous value. Using the current and previous values, we can generate rise and fall signals as sown below.\r\n\r\n    reg [2:0] async_r; always @(posedge sysClk) async_r <= { async_r[1:0], async };\r\n    wire rising = ( async_r[2:1] == 2'b01 );\r\n    wire falling = ( async_r[2:1] == 2'b10 );\r\n    wire sync = async_r[1];[\/code]\r\n<\/p>\r\n<p>\r\n    In the remainder of this article we&#8217;ll refer to the synchronized versions of these SPI signals.\r\n<\/p>\r\n\r\n<h3>\r\n    Operation\r\n<\/h3>\r\n<p>\r\n    The main data object is an 8-bit register called <code>data<\/code>, similar to the one shown on the <a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/bytes-exchange-protocol-30814\">protocol page<\/a>,\r\n    <ul>\r\n            <li>On a falling <em>SCLK<\/em> edge, the most significant bit from <code>data<\/code> is clocked into a register from where it is transmitted over its <em>MISO<\/em> output.<\/li>\r\n            <li>On a rising <em>SCLK<\/em> edge, the <em>MOSI<\/em> input is shifted into the least significant bit of <code>data<\/code>.<\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    Once all eight bits are received, the byte is available as <code>rx<\/code>. This received byte <code>rx<\/code> should be read when <code>rxValid<\/code> is active during a rising edge of the <code>sysClk<\/code>.\r\n<\/p>\r\n\r\n<h3>\r\n    Finite State Machine\r\n<\/h3>\r\n<p>\r\n    The <em>Byte module<\/em> implements the SPI Slave <a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/bytes-exchange-protocol-30814\">protocol<\/a> and converts a bit stream into bytes and visa versa. It is implemented using a state machine with 8 states, corresponding to the 8 bits per byte. The illustration below shows the Finite State Machine (FSM) with corresponding data path.\r\n<\/p>\r\n<p>\r\n    In general, a FSM is in charge and contains the state register, next-state logic and output logic. In this particular case, we didn&#8217;t require output logic. The FSM passes a control signal (<em>state<\/em>) to the the data path. The data path combines the control signal with its input signals to generate the output signals <code>rx<\/code><em>, <\/em><code>rxValid <\/code>and the <code>MISO<\/code> bitstream.\r\n<\/p>\r\n<p>\r\n    <div class=\"align-center\">\r\n        <div class=\"flow-container\">\r\n            <figure>\r\n                <a href=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-fsmd-byte-copy.svg\"><img src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-fsmd-byte-copy.svg\" alt=\"\" width=\"600\" class=\"alignnone size-large wp-image-32822\" \/><\/a>\r\n                <figcaption>\r\n                    SPI Byte Exchange FSM with Data path\r\n                <\/figcaption>\r\n            <\/figure>\r\n        <\/div>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h3>\r\n    Timing\r\n<\/h3>\r\n<p>\r\n    The timing diagram below shows the relation between the different signals. You may note that the input signal synchronization comes at the cost of introducing a delay. Given that the system clock is significantly faster then the SPI clock this should not pose a problem. The initial implementation on Xilinx used a 66 MHz system clock and a 4 MHz SPI clock as shown below.\r\n\r\n    <div class=\"align-center\">\r\n        <div class=\"flow-container\">\r\n            <figure>\r\n                <a href=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing.png\"><img src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing-1024x430.png\" alt=\"\" width=\"600\" class=\"alignnone size-large wp-image-32821\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing-1024x430.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing-400x168.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing-768x322.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing-1536x645.png 1536w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-timing.png 1760w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/><\/a>\r\n                <figcaption>\r\n                    Signals for Xilinx implementation\r\n                <\/figcaption>\r\n            <\/figure>\r\n        <\/div>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    In a later iteration on Altera, we used a PLL to create a 200 MHz system clock. The only reason for such a high clock was that we eventually plan to use it to measure coarse propagation delay in circuits. The gate level simulation result is shown below.\r\n\r\n    <div class=\"align-center\">\r\n        <div class=\"flow-container\">\r\n            <figure>\r\n                <a href=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb.png\"><img src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb-1024x289.png\" alt=\"\" width=\"600\" class=\"alignnone size-large wp-image-32820\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb-1024x289.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb-400x113.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb-768x217.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/spi-byte-tb.png 1347w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/><\/a>\r\n                <figcaption>\r\n                    Signals for Altera implementation\r\n                <\/figcaption>\r\n            <\/figure>\r\n        <\/div>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h3>\r\n    Sources\r\n<\/h3>\r\n\r\n<p>\r\n    The complete project including constraints and test bench is available through\r\n    <div class=\"flex-container tight\">\r\n         <a class=\"hide-anchor\" href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\">\r\n             <img src=\"https:\/\/socialify.git.ci\/cvonk\/FPGA_SPI\/image?description=1&#038;issues=1&#038;language=1&#038;name=1&#038;owner=1&#038;pattern=Circuit%20Board&#038;stargazers=1&#038;theme=Light\" width=\"500\" \/>\r\n         <\/a>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    Much of the credit for the byte level implementation goes to <a href=\"https:\/\/www.fpga4fun.com\/SPI.html\">fpga4fun<\/a>. My key Verilog HDL files are:\r\n    <ul>\r\n        <li>\r\n            <strong>SPI Slave Byte Main<\/strong>,\r\n            <code><a href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\/blob\/master\/spi_byte_if\/altera\/spi_byte.v\">spi_byte.v<\/a><\/code> on Altera (or\r\n            <a href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\/blob\/master\/spi_byte_if\/xilinx\/spi_byte.v\"><code>spi_byte.v<\/code><\/a> on Xilinx)\r\n        <\/li>\r\n        <li>\r\n            <strong>SPI Slave Byte Interface<\/strong>,\r\n            <code><a href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\/blob\/master\/spi_byte_if\/altera\/spi_byte_if.v\">spi_byte_if.v<\/a><\/code> on Altera (or\r\n            <a href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\/blob\/master\/spi_byte_if\/xilinx\/spi_byte_if.v\"><code>spi_byte_if.v<\/code><\/a> on Xilinx)\r\n        <\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    On the FPGA, LED[0] will be on when it receives 0xAA.  Assuming the Arduino sends alternating 0xAA and 0x55, LED[0] will blink.  It always returns 0x55 to the Arduino.\r\n<\/p>\r\n\r\n<h3>\r\n    Verification\r\n<\/h3>\r\n<p>\r\n    To verify the implementation, we ran the test bench (<a href=\"https:\/\/github.com\/cvonk\/FPGA_SPI\/blob\/master\/spi_byte_if\/altera\/spi_byte_tb.v\"><code>spi_byte_tb.v<\/code><\/a>) using gate level simulation. This test bench will monitor the communication and report errors when found. In the real world, we connected the <a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/bytes-exchange-with-arduino-as-master-30816\">Arduino SPI Master<\/a>. The program on the Arduino, alternates writing <em>0xAA<\/em> and <em>0x55<\/em> with a 10\/90 duty cycle. As a consequence the LED should blink shortly every cycle.\r\n<\/p>\r\n<p>\r\n    <div class=\"continue-container no-print\">\r\n        <div class=\"continue-content\">\r\n            <div class=\"continue-text\">\r\n                Following &#8220;SPI byte protocol on FPGA&#8221;, the next part of this article introduces a <a href=\"http:\/\/coertvonk.com\/hw\/math-talk\/message-exchange-protocol-30820\">Message Exchange Protocol<\/a>, layered on top of this byte interface. This allows us to pass 32-bit register values over the SPI byte interface.\r\n            <\/div>\r\n        <\/div>\r\n    <\/div>    \r\n<\/p>","protected":false},"excerpt":{"rendered":"Chapter 5. Implements the byte protocol on the FPGA.","protected":false},"author":41,"featured_media":32835,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"_mi_skip_tracking":false},"categories":[421],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v18.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>SPI byte protocol on FPGA - Coert Vonk<\/title>\n<meta name=\"description\" content=\"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"SPI byte protocol on FPGA - Coert Vonk\" \/>\n<meta property=\"og:description\" content=\"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818\" \/>\n<meta property=\"og:site_name\" content=\"Coert Vonk\" \/>\n<meta property=\"article:published_time\" content=\"2015-10-15T01:43:00+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-04-30T00:51:23+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png\" \/>\n\t<meta property=\"og:image:width\" content=\"200\" \/>\n\t<meta property=\"og:image:height\" content=\"168\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Coert Vonk\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"2 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebSite\",\"@id\":\"http:\/\/coertvonk.com\/#website\",\"url\":\"http:\/\/coertvonk.com\/\",\"name\":\"Coert Vonk\",\"description\":\"Embedded Software Engineer\",\"publisher\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"http:\/\/coertvonk.com\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png\",\"contentUrl\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png\",\"width\":200,\"height\":168},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage\",\"url\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818\",\"name\":\"SPI byte protocol on FPGA - Coert Vonk\",\"isPartOf\":{\"@id\":\"http:\/\/coertvonk.com\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage\"},\"datePublished\":\"2015-10-15T01:43:00+00:00\",\"dateModified\":\"2022-04-30T00:51:23+00:00\",\"description\":\"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.\",\"breadcrumb\":{\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Vonk Family\",\"item\":\"https:\/\/coertvonk.com\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Hardware\",\"item\":\"https:\/\/coertvonk.com\/category\/hw\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"Math talk\",\"item\":\"https:\/\/coertvonk.com\/category\/hw\/math-talk\"},{\"@type\":\"ListItem\",\"position\":4,\"name\":\"Byte protocol on FPGA\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#article\",\"isPartOf\":{\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage\"},\"author\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"headline\":\"Byte protocol on FPGA\",\"datePublished\":\"2015-10-15T01:43:00+00:00\",\"dateModified\":\"2022-04-30T00:51:23+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage\"},\"wordCount\":322,\"commentCount\":0,\"publisher\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"image\":{\"@id\":\"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage\"},\"thumbnailUrl\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png\",\"articleSection\":[\"Math talk\"],\"inLanguage\":\"en-US\"},{\"@type\":[\"Person\",\"Organization\"],\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\",\"name\":\"Coert Vonk\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"http:\/\/coertvonk.com\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"contentUrl\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"caption\":\"Coert Vonk\"},\"logo\":{\"@id\":\"http:\/\/coertvonk.com\/#personlogo\"},\"description\":\"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.\",\"sameAs\":[\"https:\/\/coertvonk.com\"],\"url\":\"http:\/\/coertvonk.com\/author\/cvonk\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"SPI byte protocol on FPGA - Coert Vonk","description":"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818","og_locale":"en_US","og_type":"article","og_title":"SPI byte protocol on FPGA - Coert Vonk","og_description":"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.","og_url":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818","og_site_name":"Coert Vonk","article_published_time":"2015-10-15T01:43:00+00:00","article_modified_time":"2022-04-30T00:51:23+00:00","og_image":[{"width":200,"height":168,"url":"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png","type":"image\/png"}],"twitter_card":"summary","twitter_misc":{"Written by":"Coert Vonk","Est. reading time":"2 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebSite","@id":"http:\/\/coertvonk.com\/#website","url":"http:\/\/coertvonk.com\/","name":"Coert Vonk","description":"Embedded Software Engineer","publisher":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"http:\/\/coertvonk.com\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage","inLanguage":"en-US","url":"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png","contentUrl":"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png","width":200,"height":168},{"@type":"WebPage","@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage","url":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818","name":"SPI byte protocol on FPGA - Coert Vonk","isPartOf":{"@id":"http:\/\/coertvonk.com\/#website"},"primaryImageOfPage":{"@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage"},"datePublished":"2015-10-15T01:43:00+00:00","dateModified":"2022-04-30T00:51:23+00:00","description":"Implements the SPI byte protocol on a FPGA. Enables the exchange bytes with the Arduino.. Written in Verilog HDL.","breadcrumb":{"@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Vonk Family","item":"https:\/\/coertvonk.com\/"},{"@type":"ListItem","position":2,"name":"Hardware","item":"https:\/\/coertvonk.com\/category\/hw"},{"@type":"ListItem","position":3,"name":"Math talk","item":"https:\/\/coertvonk.com\/category\/hw\/math-talk"},{"@type":"ListItem","position":4,"name":"Byte protocol on FPGA"}]},{"@type":"Article","@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#article","isPartOf":{"@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage"},"author":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"headline":"Byte protocol on FPGA","datePublished":"2015-10-15T01:43:00+00:00","dateModified":"2022-04-30T00:51:23+00:00","mainEntityOfPage":{"@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#webpage"},"wordCount":322,"commentCount":0,"publisher":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"image":{"@id":"https:\/\/coertvonk.com\/hw\/math-talk\/byte-exchange-with-a-fpga-as-slave-30818#primaryimage"},"thumbnailUrl":"https:\/\/coertvonk.com\/wp-content\/uploads\/spi-logo-mathtalk-small.png","articleSection":["Math talk"],"inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e","name":"Coert Vonk","image":{"@type":"ImageObject","@id":"http:\/\/coertvonk.com\/#personlogo","inLanguage":"en-US","url":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","contentUrl":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","caption":"Coert Vonk"},"logo":{"@id":"http:\/\/coertvonk.com\/#personlogo"},"description":"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.","sameAs":["https:\/\/coertvonk.com"],"url":"http:\/\/coertvonk.com\/author\/cvonk"}]}},"_links":{"self":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/30818"}],"collection":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/users\/41"}],"replies":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/comments?post=30818"}],"version-history":[{"count":10,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/30818\/revisions"}],"predecessor-version":[{"id":32824,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/30818\/revisions\/32824"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/media\/32835"}],"wp:attachment":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/media?parent=30818"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/categories?post=30818"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/tags?post=30818"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}