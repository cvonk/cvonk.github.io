{"id":31575,"date":"2015-10-19T18:45:12","date_gmt":"2015-10-20T01:45:12","guid":{"rendered":"https:\/\/coertvonk.com\/?p=31575"},"modified":"2022-04-27T18:02:36","modified_gmt":"2022-04-28T01:02:36","slug":"frequency-and-pitch-detection","status":"publish","type":"post","link":"http:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575","title":{"rendered":"Frequency and pitch detection"},"content":{"rendered":"<p>\r\n    Describes frequency and pitch detection for pitch detection on Arduino (<code>frequency.cpp<\/code>, <code>pitch.cpp<\/code>). The core of the application: the frequency detection algorithm. Part of the project <a href=\"\/category\/sw\/pitch-detector\">Arduino Pitch Detector<\/a>.\\(\\)\r\n<\/p>\r\n<p>\r\n    Each musical instruments create an unique set of harmonics [<a href=\"http:\/\/www.sarahtulga.com\/Harmonics.htm\">demo<\/a>]. In the commonly used E<a href=\"https:\/\/www.nctm.org\/classroomresources\/\">ven Tempered Scale<\/a>,  the <em>A4<\/em> key on the piano corresponds a fundamental frequency \\(f_0=440\\mathrm{\\ Hz}\\). Other frequencies follow as:\r\n<\/p>\r\n<p style=\"padding-left: 30px;\">\r\n        $$\r\n            f=2^{\\frac{n}{12}}\\times440\\mathrm{\\ Hz}\r\n        $$\r\n\r\n    where  \\(n\\) is the number of half-steps from middle A (A4).\r\n<\/p>\r\n\r\n<h2>\r\n    Designs considered\r\n<\/h2>\r\n<p>\r\n    The main challenge of this project is to detect the fundamental frequency of the notes played using an embedded system. The fundamental frequency is defined as the lowest frequency produced by an oscillation.\r\n<\/p>\r\n<p>\r\n    The following three methods were considered\r\n\r\n    <ol>\r\n        <li>\r\n            Using a time-domain feature such as zero crossings. This means that you find the distance between when the waveform goes from negative to positive the first time and when it does that a second time.\r\n        <\/li>\r\n        <li>\r\n            Using autocorrelation to determine the frequency of instrumental sounds as published by Judith C. Brown and Bin Zhang [<a href=\"http:\/\/academics.wellesley.edu\/Physics\/brown\/pubs\/acptrv89P2346-P2354.pdf\">Brown<\/a>, <a href=\"http:\/\/193.166.3.2\/pub\/sci\/audio\/dafx\/2000\/profs.sci.univr.it\/%257Edafx\/Final-Papers\/pdf\/Monti_DAFX00poster.pdf\">Monti<\/a>]. Autocorrelation is a math tool for finding repeating patterns. It estimates the degree to which a signal and a time lagged version of itself are correlated. A high correlation indicates a periodicity in the signal at the corresponding time lag.\r\n        <\/li>\r\n        <li>\r\n            An alternate method of calculating autocorrelation is by using a Fast Fourier Transform and approaching it similar to convolution. To get cross-correlation instead of convolution, I time-reverse one of the signals before doing the FFT, or take the complex conjugate of one of the signals after the FFT as shown in \\(R_{xx}(k)=\\mathcal{F}^{-1}\\left(\\mathcal{F}(t)\\times\\mathcal{F}(t+k)^*\\right)\\).\r\n        <\/li>\r\n    <\/ol>\r\n<\/p>\r\n<p>\r\n    A literature study revealed that using time-domain features (1) will not perform well for musical instruments, such as a clarinet, that produce harmonics that are stronger than the fundamental frequency.\r\n<\/p>\r\n<p>\r\n    Brown\u2019s method (2) is promising. It calculates the autocorrelation \\(R_{xx}\\) at lag \\(k\\) by the equation <a href=\"https:\/\/en.wikipedia.org\/wiki\/Autocorrelation\">[wiki<\/a>, <a href=\"http:\/\/www.jot.fm\/issues\/issue_2010_03\/column2.pdf\">Lyon<\/a>]\r\n<\/p>\r\n<p style=\"padding-left: 30px;\">\r\n        $$\r\n            \\begin{array}{lcc}\r\n                R_{xx}(k)=\\frac{\\sum_{t=1}^N(s_t-\\bar{s})(s_{t+k}-\\bar{s})}{\\sigma^2},&#038;\r\n                \\bar{s}=\\frac{1}{N}\\sum_{t=1}^Ns_t,&#038;\r\n                \\sigma=\\sqrt{\\frac{1}{N}\\sum_{t=1}^N(s_t-\\bar{s})^2}\r\n            \\end{array}\r\n        $$\r\n<\/p>\r\n<p>\r\n    where \\(s\\) are audio samples,  \\(N\\) is the total number of samples, and \\(k\\) is the lag,  \\(\\bar{s}\\) is the mean signal value, and \\(\\sigma^2\\) is a normalization factor. However, calculating the autocorrelation requires \\(2N\\) subtractions,  \\(N\\) additions,  \\(2N\\) multiplications, and \\(N\\) divisions. This is likely to exceed the design constraints. The image on the right shows the autocorrelation process for samples of a clarinet playing the note C4.\r\n<\/p>\r\n<p>\r\n    The alternate method of calculating autocorrelation (3) reduces the processing requirement to \\(N-\\log(N)\\), but the algorithm uses significantly more memory. This leaves less memory to store audio samples thereby reducing the window size and consequently limits the ability to recognize low frequencies.\r\n<\/p>\r\n<p>\r\n    The MIDI pitch \\(m\\) then follows as\r\n<\/p>\r\n<p style=\"padding-left: 30px;\">\r\n        $$\r\n            m = 69+12\\log_2\\frac{f}{440}\r\n        $$\r\n<\/p>\r\n\r\n<h2>\r\n    Design to find the frequency\r\n<\/h2>\r\n<p>\r\n    To detect the fundamental frequency, I simplified Brown\u2019s method by making two assumptions\r\n\r\n    <ol>\r\n            <li>The signal has no DC bias \\(\\bar{s}=0\\).<\/li>\r\n            <li>We\u2019re only interested in the lag for which the autocorrelation peaks, not the absolute value of the autocorrelation. Therefore, the normalization factor \u03c3^2 that is independent of the lag k can be ignored.<\/li>\r\n            <li>When the term \\(t+k\\) extends past the length of the series, the series is considered to be \\(0\\).<\/li>\r\n    <\/ol>\r\n<\/p>\r\n<p>\r\n    Based on these assumptions, the autocorrelation can be estimated as:\r\n<\/p>\r\n<p style=\"padding-left: 30px;\">\r\n        $$\r\n            R{xx}(k) = \\sum_{t=1}^Ns_t\\,s_{t+k}\r\n        $$\r\n<\/p>\r\n<p>\r\n    The figure below shows a visualization of the term . The original waveform  is shown in blue, and the time lagged version  in red. The black curve shows the multiplication of these signals.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/pitch-Rxx.svg\" rel=\"attachment wp-att-14723\">\r\n                    <img  title=\"\" class=\"wp-image-14723 size-full\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-Rxx.svg\" alt=\"own work; requires svg-enabled browser\" width=\"228\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                The term s(t) s(t+k). for one value of k\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The plot below shows an example of the estimated autocorrelation for \\(R_{xx}(k)\\) as a function of the lag \\(k\\). By definition the maximum autocorrelation is at lag \\(k=0\\). A peak finding algorithm looks for the first peak that exceeds a threshold at \\(\\frac{2}{3}\\) of this value. The corresponding lag \\(k\\) is considered the period time \\(T_0\\). The fundamental frequency \\(f_0\\) is simply the inverse of \\(T_0\\).\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/pitch-Rxxk.svg\" rel=\"attachment wp-att-14724\">\r\n                    <img loading=\"lazy\" class=\"aligncenter wp-image-14724\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-Rxxk.svg\" alt=\"own work; requires svg-enabled browser\" width=\"397\" height=\"279\">\r\n                <\/a>\r\n            <figcaption>\r\n                Pitch Rxx\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The listing below shows a code fragment from <code>frequency.cpp<\/code> that implements the autocorrelation function.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/icon-signal-c.png\">\r\n                    <img class=\"wp-image-13272 aligncenter\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c.png\" alt=\"own work\" width=\"664\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c.png 700w, https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c-400x150.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c-250x94.png 250w, https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c-300x113.png 300w, https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c-350x132.png 350w, https:\/\/coertvonk.com\/wp-content\/uploads\/icon-signal-c-500x188.png 500w\" sizes=\"(max-width: 700px) 100vw, 700px\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                Autocorrelation function\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h2>\r\n    Design to find the peak\r\n<\/h2>\r\n<p>\r\n    By definition the autocorrelation is maximum at lag <em>k=0<\/em>. If I find the maximum value for <em>R<sub>xx<\/sub>(k)<\/em> where <em>0\u2264k<N<\/em>, then that <em>k<\/em> is the period time. The fundamental frequency is the inverse of <em>T<sub>0<\/sub><\/em>. However, this requires calculating <em>R<sub>xx<\/sub>(k)<\/em> for all values of <em>k<\/em>.\r\n<\/p>\r\n<p>\r\n    To make it faster and less compute intensive, I chose to accept the first maximum that is above <em>2\/3\u00d7R<sub>xx<\/sub>(0)<\/em>. The first peak that exceeds this value is considered the period time (<em>T<sub>0<\/sub><\/em>). This algorithm is implemented in <code>frequency.cpp<\/code><code> <\/code>as a peak detector as shown in the code fragment below.\r\n<\/p>\r\n<p>\r\n    <div class=\"align-center\" style=\"width:80%; display:inline-block;\">\r\n        <pre class=\"brush: cpp; title: ; notranslate\" title=\"\">frequency_t const                                 \/\/ returns frequency found, 0 when not found [out]\r\nFrequency::calculate( samples_t const  samples )  \/\/ pointer to signed 8-bit data samples [in]\r\n{\r\n    float period = 0;\r\n    if ( samples ) {\r\n        samplesLag_t const lagMin = Config::LAG_MIN; \/\/ SAMPLE_LAG_MIN;\r\n        samplesLag_t const lagMax = Config::LAG_MAX;\r\n        autoCorr_t const acMax = _autoCorr( samples, 0 );  \/\/ initial peak = measure of the energy in the signal\r\n        autoCorr_t const acThreshold = acMax * 2 \/ 3;      \/\/ empirical value\r\n        autoCorr_t acPrev = 0;\r\n        State state = State::findPosSlope;   \/\/ ensure C++11 is enabled\r\n\r\n        for ( samplesLag_t lag = lagMin; (lag <> lagMax) & (state != State::secondPeak); lag++ ) {\r\n            autoCorr_t const ac = _autoCorr( samples, lag );  \/\/ unnormalized autocorrelation for time \"lag\"\r\n            switch ( state ) {  \/\/ find peak after the initial maximum\r\n                case State::findPosSlope:\r\n                    if ( (ac > acThreshold) & (ac > acPrev) ) {\r\n                        state = State::findNegSlope;\r\n                    }\r\n                    break;\r\n                case State::findNegSlope:\r\n                    if ( ac <= acPrev ) {\r\n                        state = State::secondPeak;\r\n                        period = lag - 1 + _quadInterpAdj( _autoCorr( samples, lag - 2 ),\r\n                            acPrev, ac );\r\n                    }\r\n                    break;\r\n            }\r\n            acPrev = ac;\r\n        }\r\n    }\r\n    return (period > 0 & f < Config::FREQ_MAX) ? Config::SAMPLE_RATE \/ period : 0;\r\n}<\/pre>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    A complementary simulation in GNU Octave visualizes the algorithm, making the process easier to understand and fine tune. The video below shows the calculation of <em>R<sub>xx<\/sub>(k)<\/em>, and the peak finding algorithm. To run the simulation yourself, load the file <code>simulation\/file2pitch.m<\/code>. in GNU Octave or Matlab.\r\n\r\n    <div class=\"video-container\">\r\n        <video src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-rxx-peak.m4v\" preload=\"auto\"><\/video>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h2>\r\n    Analyzing accuracy\r\n<\/h2>\r\n<p>\r\n    To analyze the accuracy  from the device, I used a spreadsheet. Testing and analysis revealed that the sample rate and window size determine the maximum and minimum frequency that can be recognized. These variables can be configured in <code>config.h<\/code>.\r\n\r\n    <ol>\r\n            <li>If the <strong>sample rate<\/strong> is to low, high frequencies will only have a few audio samples per period, causing these frequencies not to be accurately recognized. Given that the frequency will be rounded to a note pitch, we can allow for an error rate of \u00b12\u00bd%.<\/li>\r\n            <li>The <strong>window size<\/strong> is the number of audio samples that are processed at the time in the autocorrelation loop. If the windows size is too small, low frequencies cannot be recognized. The number of audio samples should be at least twice the maximum period time for autocorrelation to work.<\/li>\r\n            <li>The <strong>delay<\/strong> is caused by the sampling of the input, calculating the frequency and the segmentation algorithm. The highest delay occurs at the lowest frequency, approximately 60 milliseconds. This was noticeable but acceptable. I observed that my simple synthesizer software introduced a noticeable additional delay. The delay was minimized by sampling audio while doing the calculations, and by stopping the autocorrelation as soon as the frequency could be determined.<\/li>\r\n    <\/ol>\r\n<\/p>\r\n<p>\r\n    The project\u2019s aim is to recognize the range of notes produced by a B\u266d clarinet. The B\u266d clarinet is a transposing instrument. When playing a C note, it will sound like a B\u266d. This clarinet can produce notes from E\u266d3 to G6, corresponding to a fundamental frequency from f<sub>1<\/sub>=155.6 to f<sub>2<\/sub>=1568 Hz.\r\n<\/p>\r\n<p>\r\n    To stay within the error rate of \\(\\pm2.5%\\), the sample rate \\(f_{s1}\\) follows as\r\n\r\n        $$\r\n            f_{s1} = \\frac{f_2}{2.5%}=31,360\\mathrm{\\ Hz}\r\n        $$\r\n<\/p>\r\n<p>\r\n    The Arduino can only sample an analog signal at multiples of \\(16\\mathrm{\\ MHz}\/128\/13=9,615\\mathrm{\\ kHz}\\) , therefore I need to round the sampling rate up to \\{f_{s2}\\)\r\n\r\n        $$\r\n            f_{s2} = 38,461\\mathrm{\\ Hz}\r\n        $$\r\n<\/p>\r\n<p>\r\n    The corresponding sample window size \\(N_2\\) follows\r\n\r\n        $$\r\n            N_2 = 2\\frac{f_{s2}}{f_1}=2\\frac{38,461}{155.6}\\approx495\r\n        $$\r\n<\/p>\r\n<p>\r\n    This well exceeds the 200 bytes of SDRAM memory that are available on the Arduino to store audio samples.\r\n<\/p>\r\n\r\n<h2>\r\n    Improving accuracy\r\n<\/h2>\r\n<p>\r\n    <img class=\"alignright wp-image-14722\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-idea.jpg\" alt=\"ms word clipart\" width=\"48\" \/>\r\n\r\n    I ported my frequency detection code to GNU Octave to enhance my visual understanding of the algorithm. I found this especially helpful in determining the empirical threshold for the peak finding algorithm.\r\n<\/p>\r\n<p>\r\n    After the normal <strong>peak finding algorithm<\/strong> determines the maximum auto correlation value \\(k_2\\). It then fits a parabola through the autocorrelation value itself, the one before (\\(k_1\\)) and the one after (\\(k_3\\)). It determines the lag that corresponds to the maximum value of the parabola.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/pitch-Rxxk-interpolated.svg\" rel=\"attachment wp-att-14725\">\r\n                    <img class=\"aligncenter wp-image-14725\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-Rxxk-interpolated.svg\" alt=\"own work; requires svg-enabled browser\" width=\"285\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                Interpolation\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    Fitting the data points to a parabola, I can find the correction factor \\(\\delta\\) as described in [<a href=\"https:\/\/users.rowan.edu\/~hassen\/NumerAnalysis\/Interpolation_and_Approximation.pdf\">Hassen<\/a>, <a href=\"http:\/\/www.jot.fm\/issues\/issue_2010_03\/column2.pdf\">Lyon<\/a>]\r\n\r\n        $$\r\n            \\delta=\\frac{k_3-k_{????}}{2(2k_2-k_1-k_3)}\r\n        $$\r\n<\/p>\r\n<p>\r\n    The corresponding sample window size \\(N_2\\) becomes\r\n\r\n        $$\r\n            N_2 = 2\\frac{f_{s3}}{f_1}=2f_{s3}\\frac{9,615}{155.6}\\approx125\r\n        $$\r\n<\/p>\r\n<p>\r\n    I rounded the window size \\(N_3\\) up to all the available 200 bytes\r\n\r\n        $$\r\n            N_3=200\r\n        $$\r\n<\/p>\r\n\r\n<h3>\r\n    Improving speed\r\n<\/h3>\r\n<p>\r\n    <img class=\"alignright wp-image-14722\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-idea.jpg\" alt=\"ms word clipart\" width=\"48\" \/>The fundamental frequency requires calculating \\(R_{xx}\\) for all values of \\(k\\) . However, the possible values of \\(k\\) are limited by the window size and sample frequency. The window size limits the lowest frequency, while the sample frequency limits the highest frequency. I empirically determined the minimum lag at \\(k=6\\). Therefore, the speed can be improved by only looking for between the corresponding time lag \\(k\\).\r\n\r\n        $$\r\n            6\\lt k\\lt \\frac{N_3}{2}\r\n        $$\r\n<\/p>\r\n<p>\r\n    where \\(N_3\\) is the window size. This corresponds to a frequency range from 96 to 1568 Hz as in\r\n\r\n        $$\r\n            \\frac{2f{s3}}{N_3}\\lt ;f\\lt \\frac{f_{s3}}{6.132}\r\n        $$\r\n<\/p>\r\n<p>\r\n    However, the frequency range measured was E\u266d3 (155.5 Hz) to G6 (1568 Hz).\r\n<\/p>\r\n\r\n<h2>\r\n    Improving range\r\n<\/h2>\r\n<p>\r\n    <img class=\"alignright wp-image-14722\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/pitch-idea.jpg\" alt=\"ms word clipart\" width=\"48\" \/>\r\n    \r\n    I tried normalizing the autocorrelation for the zeroes introduced by the lag. To do this, I multiplied by a correction factor of  . The normalized autocorrelation formula is\r\n\r\n        $$\r\n            R{xx}(k)=\\frac{N}{N-k}\\sum_{t=1}^Ns_t\\,s_{t+k}\r\n        $$\r\n<\/p>\r\n<p>\r\n    This extends the range for piano samples from G2 (98 Hz) to G\u266d6 (1480 Hz) as shown in the Figure below.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/200S-piano-ip-and-ipnac80.png\">\r\n                <img class=\"wp-image-14726 size-large\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80-1024x742.png\" alt=\"own work\" width=\"600\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80-1024x742.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80-300x217.png 300w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80-768x556.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80-400x290.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac80.png 1889w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>\r\n                Piano, fs=9615Hz, N=200, with interpolation, normalized, threshold=80%\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    It however also misses a high note for the clarinet as shown in the Figure below.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80.png\">\r\n                    <img class=\"wp-image-14727 size-large\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80-1024x743.png\" alt=\"own work\" width=\"600\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80-1024x743.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80-300x218.png 300w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80-768x557.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80-400x290.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac80.png 1889w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                Clarinet, fs=9615Hz, N=200, with interpolation, normalized, threshold=80%\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    You can still get that high clarinet note, if you lower the threshold from 80% to 71% as shown in the Figure below.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71.png\">\r\n                    <img class=\"wp-image-14728 size-large\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71-1024x743.png\" alt=\"own work\" width=\"600\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71-1024x743.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71-300x218.png 300w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71-768x557.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71-400x290.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-clarinet-ip-and-ipnac71.png 1889w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                Clarinet, fs=9615Hz, N=200, with interpolation, normalized, threshold=71%\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    However, it then misses a low note for piano as shown in the Figure below.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n                <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/200S-piano-ip-and-ipnac71.png\">\r\n                    <img class=\"wp-image-14729 size-large\" src=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-1024x742.png\" alt=\"own work\" width=\"600\" srcset=\"https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-1024x742.png 1024w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-400x290.png 400w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-768x557.png 768w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-250x181.png 250w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-300x217.png 300w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-350x254.png 350w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-500x362.png 500w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71-750x544.png 750w, https:\/\/coertvonk.com\/wp-content\/uploads\/200S-piano-ip-and-ipnac71.png 1887w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n                <\/a>\r\n            <figcaption>\r\n                Piano, fs=9615Hz, N=200, with interpolation, normalized, threshold=71%\r\n            <\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    For clarinet, normalization only adds one low note to the range, while causing the frequency to be less accurate. As a result, I decided to not use normalization for clarinet. The results for this are shown in the conclusion.\r\n<\/p>\r\n<p>\r\n    <div class=\"continue-container no-print\">\r\n        <div class=\"continue-content\">\r\n            <div class=\"continue-text\">\r\n                Continue reading on the <a href=\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/note-level-segmentation-and-buffering-31577\">next page<\/a> to learn about note level segmentation.\r\n        <\/div>\r\n    <\/div>    \r\n<\/p>\r\n","protected":false},"excerpt":{"rendered":"Describes frequency and pitch detection for pitch detection on Arduino.  The core of the application: the frequency detection algorithm.","protected":false},"author":41,"featured_media":18417,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"_mi_skip_tracking":false},"categories":[433],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v18.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Frequency and pitch detection for pitch detection on Arduino - Johan Vonk<\/title>\n<meta name=\"description\" content=\"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Frequency and pitch detection for pitch detection on Arduino - Johan Vonk\" \/>\n<meta property=\"og:description\" content=\"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575\" \/>\n<meta property=\"og:site_name\" content=\"Coert Vonk\" \/>\n<meta property=\"article:published_time\" content=\"2015-10-20T01:45:12+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-04-28T01:02:36+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png\" \/>\n\t<meta property=\"og:image:width\" content=\"300\" \/>\n\t<meta property=\"og:image:height\" content=\"300\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Coert Vonk\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"4 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebSite\",\"@id\":\"http:\/\/coertvonk.com\/#website\",\"url\":\"http:\/\/coertvonk.com\/\",\"name\":\"Coert Vonk\",\"description\":\"Embedded Software Engineer\",\"publisher\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"http:\/\/coertvonk.com\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png\",\"contentUrl\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png\",\"width\":300,\"height\":300},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage\",\"url\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575\",\"name\":\"Frequency and pitch detection for pitch detection on Arduino - Johan Vonk\",\"isPartOf\":{\"@id\":\"http:\/\/coertvonk.com\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage\"},\"datePublished\":\"2015-10-20T01:45:12+00:00\",\"dateModified\":\"2022-04-28T01:02:36+00:00\",\"description\":\"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.\",\"breadcrumb\":{\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Vonk Family\",\"item\":\"https:\/\/coertvonk.com\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Software\",\"item\":\"https:\/\/coertvonk.com\/category\/sw\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"Arduino\",\"item\":\"https:\/\/coertvonk.com\/category\/sw\/arduino\"},{\"@type\":\"ListItem\",\"position\":4,\"name\":\"Pitch detection\",\"item\":\"https:\/\/coertvonk.com\/category\/sw\/arduino\/pitch-detector\"},{\"@type\":\"ListItem\",\"position\":5,\"name\":\"Frequency and pitch detection\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#article\",\"isPartOf\":{\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage\"},\"author\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"headline\":\"Frequency and pitch detection\",\"datePublished\":\"2015-10-20T01:45:12+00:00\",\"dateModified\":\"2022-04-28T01:02:36+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage\"},\"wordCount\":752,\"commentCount\":0,\"publisher\":{\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"image\":{\"@id\":\"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage\"},\"thumbnailUrl\":\"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png\",\"articleSection\":[\"Pitch detection\"],\"inLanguage\":\"en-US\"},{\"@type\":[\"Person\",\"Organization\"],\"@id\":\"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\",\"name\":\"Coert Vonk\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"http:\/\/coertvonk.com\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"contentUrl\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"caption\":\"Coert Vonk\"},\"logo\":{\"@id\":\"http:\/\/coertvonk.com\/#personlogo\"},\"description\":\"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.\",\"sameAs\":[\"https:\/\/coertvonk.com\"],\"url\":\"http:\/\/coertvonk.com\/author\/cvonk\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Frequency and pitch detection for pitch detection on Arduino - Johan Vonk","description":"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575","og_locale":"en_US","og_type":"article","og_title":"Frequency and pitch detection for pitch detection on Arduino - Johan Vonk","og_description":"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.","og_url":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575","og_site_name":"Coert Vonk","article_published_time":"2015-10-20T01:45:12+00:00","article_modified_time":"2022-04-28T01:02:36+00:00","og_image":[{"width":300,"height":300,"url":"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png","type":"image\/png"}],"twitter_card":"summary","twitter_misc":{"Written by":"Coert Vonk","Est. reading time":"4 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebSite","@id":"http:\/\/coertvonk.com\/#website","url":"http:\/\/coertvonk.com\/","name":"Coert Vonk","description":"Embedded Software Engineer","publisher":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"http:\/\/coertvonk.com\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage","inLanguage":"en-US","url":"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png","contentUrl":"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png","width":300,"height":300},{"@type":"WebPage","@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage","url":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575","name":"Frequency and pitch detection for pitch detection on Arduino - Johan Vonk","isPartOf":{"@id":"http:\/\/coertvonk.com\/#website"},"primaryImageOfPage":{"@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage"},"datePublished":"2015-10-20T01:45:12+00:00","dateModified":"2022-04-28T01:02:36+00:00","description":"Describes frequency and pitch detection for pitch detection on Arduino. The core of the application: the frequency detection algorithm.","breadcrumb":{"@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Vonk Family","item":"https:\/\/coertvonk.com\/"},{"@type":"ListItem","position":2,"name":"Software","item":"https:\/\/coertvonk.com\/category\/sw"},{"@type":"ListItem","position":3,"name":"Arduino","item":"https:\/\/coertvonk.com\/category\/sw\/arduino"},{"@type":"ListItem","position":4,"name":"Pitch detection","item":"https:\/\/coertvonk.com\/category\/sw\/arduino\/pitch-detector"},{"@type":"ListItem","position":5,"name":"Frequency and pitch detection"}]},{"@type":"Article","@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#article","isPartOf":{"@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage"},"author":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"headline":"Frequency and pitch detection","datePublished":"2015-10-20T01:45:12+00:00","dateModified":"2022-04-28T01:02:36+00:00","mainEntityOfPage":{"@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#webpage"},"wordCount":752,"commentCount":0,"publisher":{"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"image":{"@id":"https:\/\/coertvonk.com\/sw\/arduino\/pitch-detector\/frequency-and-pitch-detection-31575#primaryimage"},"thumbnailUrl":"https:\/\/coertvonk.com\/wp-content\/uploads\/johan-pitch-detector-logo4.png","articleSection":["Pitch detection"],"inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"http:\/\/coertvonk.com\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e","name":"Coert Vonk","image":{"@type":"ImageObject","@id":"http:\/\/coertvonk.com\/#personlogo","inLanguage":"en-US","url":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","contentUrl":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","caption":"Coert Vonk"},"logo":{"@id":"http:\/\/coertvonk.com\/#personlogo"},"description":"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.","sameAs":["https:\/\/coertvonk.com"],"url":"http:\/\/coertvonk.com\/author\/cvonk"}]}},"_links":{"self":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/31575"}],"collection":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/users\/41"}],"replies":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/comments?post=31575"}],"version-history":[{"count":10,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/31575\/revisions"}],"predecessor-version":[{"id":32772,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/posts\/31575\/revisions\/32772"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/media\/18417"}],"wp:attachment":[{"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/media?parent=31575"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/categories?post=31575"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/coertvonk.com\/wp-json\/wp\/v2\/tags?post=31575"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}