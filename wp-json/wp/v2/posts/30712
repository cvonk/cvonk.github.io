{"id":30712,"date":"2010-10-20T16:23:20","date_gmt":"2010-10-20T23:23:20","guid":{"rendered":"https:\/\/coert.vonk.one\/?p=30712"},"modified":"2022-05-03T12:59:45","modified_gmt":"2022-05-03T19:59:45","slug":"synchronous-sequential-logic","status":"publish","type":"post","link":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712","title":{"rendered":"Synchronous sequential"},"content":{"rendered":"<p>\r\n    The logic circuits that we have seen so far are referred to as <em>combinatorial circuits<\/em>. While these circuits can be used quite successfully for math operations, their simplicity comes at a price:\r\n    <ul>\r\n        <li>The input values need to remain constant during the calculation.<\/li>\r\n        <li>The output can have multiple logical transitions before settling to the correct value. The figure below shows that even adding two numbers without carry may cause multiple transitions.<\/li>\r\n        <li>There is no indication when the output has settled to the correct value.<\/li>\r\n    <\/ul>\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n        <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-combinational-settling.png\">\r\n            <img class=\"wp-image-3911 size-full\"  title=\"\"  src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png\" alt=\"(c) Copyright 2011 Coert Vonk\" width=\"354\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png 354w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling-250x95.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling-300x114.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling-350x132.png 350w\" sizes=\"(max-width: 354px) 100vw, 354px\" \/>\r\n        <\/a>\r\n        <figcaption>adding 32&#8217;d0 to 32&#8217;d1 implemented on Altera FPGA<\/figcaption><\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    This chapter address solutions to some of these issues by introducing <em>sequential circuits<\/em> in which where the output not only depends on the current inputs, but also on the past sequence of the inputs values. That is, sequential logic has state (memory). [<a href=\"https:\/\/en.wikipedia.org\/wiki\/Sequential_logic\">wiki<\/a>]\r\n<\/p>\r\n<p>\r\n    In general, such a memory element can be made using positive feedback.\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-positive-feedback2.png\"><img loading=\"lazy\" class=\"wp-image-3861\" title=\"(c) Copyright 2011 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-positive-feedback2.png\" alt=\"(c) Copyright 2011 Coert Vonk\" width=\"172\" height=\"109\" \/><\/a>\r\n            <figcaption>Memory element using positive feedback<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    Digital sequential logic circuits are divided into asynchronous and synchronous circuits.\r\n<\/p>\r\n\r\n<h3>\r\n    Asynchronous\r\n<\/h3>\r\n\r\n<p>\r\n    The advantage of asynchronous circuits is that the speed is only limited by the propagation delays of the gates, because the circuit does not have to wait for a clock signal to process inputs.\r\n<\/p>\r\n<p>\r\n    The state of asynchronous circuits can change at any time in response to changing inputs. As a result, similar to combinatorial circuits, the output can have multiple logical transitions before settling to the correct value.\r\n<\/p>\r\n<p>\r\n    Another disadvantage arises from the fact that memory elements are sensitive to the order that their input signals arrive. If two signals arrive at a logic gate at almost the same time, which state the circuit goes into can depend on which signal gets to the gate first. This may causes small manufacturing differences to lead to different behavior.\r\n<\/p>\r\n<p>\r\n    These disadvantages make designing asynchronous circuits very challenging and limited to critical parts where speed is at a premium. [<a href=\"https:\/\/en.wikipedia.org\/wiki\/Sequential_logic\">wiki<\/a>]\r\n<\/p>\r\n<p>\r\n    A very basic memory element can be made using only two inverters. This circuit will maintain its state, but lacking any input that state cannot be changed.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-not-not-gates.png\">\r\n                <img class=\"wp-image-3829\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-not-not-gates.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"150\" \/>\r\n            <\/a>\r\n            <figcaption>Basic memory element using inverters<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    We continue with some common asynchronous circuits.\r\n<\/p>\r\n\r\n<h4>\r\n    Set-Reset (SR) Latch (async, level sensitive)\r\n<\/h4>\r\n\r\n<p>\r\n    The SR-latch builds on the idea of the inverter latch and introducing two inputs. Set (\\(S\\)), forces the next value of the output (\\(Q_{n+1}\\)) to \\(1\\). Reset (\\(R\\)), force the next value of the output (\\(Q_{n+1}\\)) to \\(0\\).\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple.png\">\r\n                <img class=\"wp-image-3870\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"128\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple.png 361w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple-250x159.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple-300x191.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-simple-350x223.png 350w\" sizes=\"(max-width: 361px) 100vw, 361px\" \/>\r\n            <\/a>\r\n            <figcaption>SR-latch states<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The state transition diagram provides a visual abstraction. It uses circles for the output states, and arrows for the transition conditions.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2.png\">\r\n                <img class=\"wp-image-3877\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"252\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2.png 644w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2-400x143.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2-250x89.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2-300x107.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2-350x125.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-state-diagram-complete2-500x179.png 500w\" sizes=\"(max-width: 644px) 100vw, 644px\" \/>\r\n            <\/a>\r\n            <figcaption>SR-latch with transitions<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-sr-latch-truth-table3.png\">\r\n                <img class=\"wp-image-3874\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-truth-table3.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"89\" \/>\r\n            <\/a>\r\n            <figcaption>A complete diagram takes all the inputs (<em>R<\/em> and <em>S<\/em>) into account.<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The state transition table shows the relationship between the inputs, the <em>current<\/em> value of the output \\((Q_n\\)), and the <em>next<\/em> value of the output (\\(Q_{n+1}\\)). The \u2018<em>\u00d7<\/em>\u2018 represents a \u201cdon\u2019t care\u201d condition.\r\n<\/p>\r\n<p>\r\n    In Boolean algebra, this function can be expressed as:\\(\\)\r\n    $$\r\n        \\begin{align*}\r\n            Q_{n+1} &#038;= S+\\overline{R}\\cdot{Q_n} \\\\\r\n            &#038;= \\overline{\\overline{S+Q_n}+R}\r\n        \\end{align*}\r\n    $$\r\n<\/p>\r\n<p>\r\n    The function can be built with two NOR gates as shown below.\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-sr-latch-gates.png\">\r\n                <img class=\"wp-image-3826\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"220\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates.png 439w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates-400x141.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates-250x88.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates-300x106.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-sr-latch-gates-350x124.png 350w\" sizes=\"(max-width: 439px) 100vw, 439px\" \/>\r\n            <\/a>\r\n            <figcaption>Memory element using NOR gates<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    With the circuit in hand, let us take a closer look at its operation:\r\n    <ul>\r\n        <li>When <em>S=1<\/em> while <em>R=0<\/em>, drives output <em>Q<\/em> to <em>1<\/em>.<\/li>\r\n        <li>When<em> R=1<\/em> while <em>S=0<\/em>, drives output <em>Q<\/em> to <em>0<\/em>.<\/li>\r\n        <li>When <em>S=R=0<\/em>, the latch latches and maintains it&#8217;s previously state.<\/li>\r\n        <li>When both inputs change to <em>1<\/em> sufficiently close in time, there is a problem. Whatever gate is first, will win the <em>race condition<\/em>. In the real world, it is impossible to predict which gate that would be, since it depends on minute manufacturing differences. A similar problem occurs when the device powers and both \\(Q\\) and \\(\\overline Q\\) are \\(0\\).<\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    In Verilog HDL we could model this as\r\n    \r\n    module SR_latch( input S, input R, output Q );\r\n    wire Qbar;\r\n    nor( Q, R, Qbar ); \r\n    nor( Qbar, S, Q );\r\nendmodule\r\n<\/p>\r\n\r\n<h4>\r\n    D-latch (async, level sensitive)\r\n<\/h4>\r\n\r\n<p>\r\n    Here a \\(D\\) input makes the \\(R\\) and \\(S\\) complements of each other, thereby removing the possibility of invalid input states (metastability) as we saw in the SR-latch. <em>\\(D=1\\)<\/em> sets the latch to <code>1<\/code>, and <em>\\(D=0\\)<\/em> resets the latch to <code>0<\/code>.\r\n<\/p>\r\n<p>\r\n    Note that in the circuit below the SR-latch here is drawn as cross-coupled NOR gates.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-d-flip-flip3.png\">\r\n                <img class=\"wp-image-3799\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"240\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3.png 672w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3-400x193.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3-250x121.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3-300x145.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3-350x169.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip3-500x242.png 500w\" sizes=\"(max-width: 672px) 100vw, 672px\" \/>\r\n            <\/a>\r\n            <figcaption>D-latch<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    An enable signal controls when the value of the inputs \\(R\\) and \\(S\\) input matter. The output reflects the input only when enable is active (\\(EN=1\\)). In other words, the enable signal serves as a level triggered clock input. Level triggered means that the input is passed to the output for was long as the clock is active.\r\n<\/p>\r\n<p>\r\n    D-latches cannot be chained, because changes will just race through the chain. Once could prevent this by inverting the ENABLE signal going to the 2<sup>nd<\/sup> D-latch.\r\n<\/p>\r\n<p>\r\n    In Verilog HDL we would model this as\r\n\r\n    module D_latch( input D, input Enable, output Q );\r\n    always @(D or Enable)\r\n    if (Enable)\r\n    Q &#038;<= D;\r\nendmodule[\/code]\r\n<\/p>\r\n        \r\n<h3>\r\n    Synchronous circuits\r\n<\/h3>\r\n        \r\n<p>\r\n    In <em>synchronous<\/em> circuits, a <em>clock signal<\/em> synchronizes state transitions. Inputs are only sampled during the active edge of the clock cycle. Outputs are \u201cheld\u201d until the next state is computed, thereby preventing multiple logical transitions. Changes to the logic signals throughout the circuit all begin at the same time, synchronized by the clock.\r\n<\/p>\r\n<p>\r\n    The figure below shows an example of a synchronous sequential circuit. In it, a D flip-flop serves as a clocked memory element. The following section will examine the various memory element.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-block.png\">\r\n                <img class=\"wp-image-3796\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"280\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block.png 841w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-400x141.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-768x271.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-250x88.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-300x106.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-350x124.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-500x177.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-block-750x265.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>Example of a synchronous circuit<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The main advantage of synchronous logic is its simplicity. The logic gates which perform the operations on the data require a finite amount of time to respond to changes to their inputs. This is called propagation delay. The interval between clock pulses must be long enough so that all the logic gates have time to respond to the changes and their outputs &#8220;settle&#8221; to stable logic values, before the next clock pulse occurs. As long as this condition is met (ignoring certain other details) the circuit is guaranteed to be stable and reliable. This determines the maximum operating speed of a synchronous circuit.\r\n<\/p>\r\n<p>\r\n    Synchronous circuits also have disadvantages. The maximum clock signal is determined by the slowest (critical) path in the circuit, because every operation must complete in one clock cycle. The best work-around is by making all the paths take roughly the same time, by splitting complex operations into several simple operations, which can be performed over multiple clock cycles. (pipelining)\r\n<\/p>\r\n<p>\r\n    In addition, synchronous circuits require the usually high clock frequency to be distributed throughout the circuit, causing power dissipation.\r\n<\/p>\r\n\r\n<h4>\r\n    D flip-flop (edge triggered)\r\n<\/h4>\r\n\r\n<p>\r\n    The classic D-flip-flop is similar to a D-latch, except for the important fact that it only samples the input on a clock transition; in this case that is the rising <strong>edge<\/strong> of the clock.\r\n<\/p>\r\n<p>\r\n    In other words, while \\(clk=0\\) the value of \\(D\\) is copied in the first latch. The moment that \\(clk\\) becomes \\(1\\), that value remains stable and is copied to output \\(Q\\).\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered.png\">\r\n                <img class=\"wp-image-3801\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"239\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered.png 718w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered-400x168.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered-250x105.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered-300x126.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered-350x147.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-d-flip-flip-edge-triggered-500x210.png 500w\" sizes=\"(max-width: 718px) 100vw, 718px\" \/>\r\n            <\/a>\r\n            <figcaption>D-flip-flop<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The use of the clock signal implies that the flip-flop cannot just hold its previous value and samples the input every rising clock edge. Note that the \u2018<code>><\/code>\u2018 symbol indicates that the clock input is sampled on the rising clock edge.\r\n<\/p>\r\n<p>\r\n    The advantage of triggering on the clock edge, is that the input signal only needs to remain stable while it is being copied to the second latch. The so-called <em>timing window<\/em>:\r\n    \r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/clock-window.png\">\r\n                <img loading=\"lazy\" class=\"wp-image-3882\" title=\"(c) Copyright 2013-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-window.png\" alt=\"(c) Copyright 2013-2021 Coert Vonk\" width=\"132\" height=\"559\" \/>\r\n            <\/a>\r\n            <figcaption>D-flip-flop timing<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    In this timing window, the setup time \\(t_su\\) is the minimum time before rising clock by which the input must be stable. The hold time \\(t_h\\) is the minimum time after the clock event during which the input must remain stable. The clock-to-output (propagation) delay \\(t_{cq}\\) is the maximum time after the clock event for the output to change.\r\n<\/p>\r\n<p>\r\n    A setup or hold violation causes metastability where the output goes to intermediate voltage values which are eventually resolved to an unknown state.\r\n<\/p>\r\n<p>\r\n    In Verilog HDL we would model this as\r\n\r\n    module D_flipflop( input D, input clock, output Q );\r\n    always @(posedge clock)\r\n    Q &#038;<= D;\r\n    endmodule[\/code]\r\n<\/p>\r\n<p>\r\n    The example above is provided for general understanding of the principle. In practice, one would use the better and more efficient solutions only requiring 6 NOR gates. This solution prevents the inverter in on the enable input of the first latch.\r\n<\/p>\r\n\r\n<h4>\r\n    register\r\n<\/h4>\r\n\r\n<p>\r\n    A register is a memory element that expands on the D-flip-flip. A load signal \\(LD\\), limits when new data is loaded into the register (only if \\(LD=1\\) during the active edge of the clock). In the circuit below, this is implemented using a 2:1 multiplexer.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-register.png\">\r\n                <img loading=\"lazy\" class=\"wp-image-3915\" title=\"(c) Copyright 2015-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-register.png\" alt=\"(c) Copyright 2015-2021 Coert Vonk\" width=\"240\" height=\"809\" \/>\r\n            <\/a>\r\n            <figcaption>Register<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    Multiple data bits are stored together. An \\(n\\)-bit register consists of \\(n\\) blocks that share the \\(LD\\) and \\(clk\\) signals.\r\n<\/p>\r\n<p>\r\n    A sequence of bits is commonly written as \\(D[15:0]\\) referring to bits \/(D_{15}\\dots D_0\/).\r\n<\/p>\r\n\r\n<h4>\r\n    Large memories\r\n<\/h4>\r\n\r\n<p>\r\n    Memory consists of a large number of locations that each can store a value. Each location in a memory is given a number, called an address.\r\n<\/p>\r\n<p>\r\n    Memory locations are identified by a \\(k\\)-bit wide address. Each memory location can store a \\(n\\)-bit wide value.\r\n<\/p>\r\n<p>\r\n    The figure below gives an example of 16-bit addresses storing 16-bit values. To save space in this figure, hexadecimal (base-16) notation is used to represent the address and value.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/architecture-memory-address.png\">\r\n                <img class=\"wp-image-3938\" title=\"(c) Copyright 2016-2022 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address.png\" alt=\"\" width=\"133\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address.png 408w, https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address-221x400.png 221w, https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address-138x250.png 138w, https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address-166x300.png 166w, https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address-194x350.png 194w, https:\/\/coert.vonk.one\/wp-content\/uploads\/architecture-memory-address-277x500.png 277w\" sizes=\"(max-width: 408px) 100vw, 408px\" \/>\r\n            <\/a>\r\n            <figcaption>Memory example<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    Bit density is key in building large memories. Instead of D flip-flops, large memories use more efficient methods such as:\r\n    <ul>\r\n        <li>Static Random Access Memory (SRAM) that uses six transistors per memory bit. As we have seen this relies on a feedback between two gates.<\/li>\r\n        <li>Dynamic Random Access Memory (DRAM) that uses only one transistor per memory bit. The mechanism relies on an electrical charge stored in the capacitor of a MOSFET gate. The drawback is that the charge has to be refreshed periodically.<\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    Let&#8217;s take a closer look at DRAM: a single bit (cell) can be implemented as shown below. In this, the capacitor saves the state. The transistor limits access to the capacitor.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/memory-dram-cell2.png\">\r\n                <img loading=\"lazy\" class=\"wp-image-3942\" title=\"(c) Copyright 2016-2022 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-cell2.png\" alt=\"\" width=\"70\" height=\"232\" \/>\r\n            <\/a>\r\n            <figcaption>DRAM cell<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    To read, <em>select<\/em> raised; the charge in the capacitor the appears on pin <em>D<\/em>. To write, select is raised for long enough to charge or drain the capacitor to the value of <em>D<\/em>.\r\n<\/p>\r\n<p>\r\n    These cells can be combined for form a large memory. The cells are organized in a matrix structure, to keep the size of the address demultiplexer practical. Otherwise, to implement <em>k<\/em> address lines, a demux with 2<em>k<\/em> outputs would be needed. The figure below shows a simplified structure implementation using a 4-bit address (and 1 bit wide).\r\n<\/p>\r\n<p>\r\n    To make a <em>n<\/em>-bit wide memory, <em>n<\/em> memory DRAM chips can be combined.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/memory-dram-matrix.png\">\r\n                <img class=\"wp-image-3940\" title=\"(c) Copyright 2016-2022 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-matrix.png\" alt=\"\" width=\"297\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-matrix.png 1113w, https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-matrix-150x150.png 150w, https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-matrix-297x300.png 297w, https:\/\/coert.vonk.one\/wp-content\/uploads\/memory-dram-matrix-1014x1024.png 1014w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>nxn DRAM<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    For more info refer to slides from MIT lectures \u201d<a href=\"http:\/\/web.mit.edu\/6.111\/www\/s2004\/LECTURES\/l4.pdf\">Sequential building blocks<\/a>\u201d and \u201c<a href=\"http:\/\/web.mit.edu\/6.111\/www\/s2004\/LECTURES\/l4.pdf\">Memory Elements<\/a>\u201d and the web site <a href=\"https:\/\/lwn.net\/Articles\/250967\/\">lwn.net<\/a>)\r\n<\/p>\r\n\r\n<h3>\r\n    Good design practices\r\n<\/h3>\r\n\r\n<p>\r\n    [<a href=\"https:\/\/www.eng.auburn.edu\/~strouce\/class\/elec4200\/flip-flop.pdf\">src<\/a>]\r\n    <ul>\r\n        <li>Use a single clock, single edge synchronous design wherever possible.<\/li>\r\n        <li>Asynchronous interfaces lead to metastability. Minimize the asynchronous interface and use a double clock data to reduce the chance of metastability.<\/li>\r\n        <li>Avoid asynchronous presets &#038; clears on FFs. Use synchronous presets &#038; clears whenever possible.<\/li>\r\n        <li>Do not gate clocks! Instead, create clock enabled FFs via a MUX to feed back current data.<\/li>\r\n    <\/ul>\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n        <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/bad2.png\">\r\n            <img class=\"wp-image-16475\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2.png\" alt=\"src: eng.auburn.edu\" width=\"327\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2.png 844w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-400x109.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-768x209.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-250x68.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-300x82.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-350x95.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-500x136.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/bad2-750x204.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n        <\/a>\r\n        <figcaption>BAD <a class=\"hide-anchor\">, source: auburn.edu<\/a><figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h3>\r\n    Clock\r\n<\/h3>\r\n\r\n<p>\r\n    In sequential circuits, a clock signal orchestrates the state transitions. This clock is generally a square wave generated by an astable multivibrator.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/clock-cycle4.png\">\r\n                <img class=\"wp-image-3853\" title=\"(c) Copyright 2014-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4.png\" alt=\"(c) Copyright 2014-2021 Coert Vonk\" width=\"265\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4.png 992w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-400x113.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-768x216.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-250x70.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-300x84.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-350x98.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-500x141.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/clock-cycle4-750x211.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>Clock signal<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    A delayed negative feedback causing it to oscillates between <code>0<\/code> and <code>1<\/code> .\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/sequential-negative-feedback.png\">\r\n                <img class=\"wp-image-3862\" title=\"(c) Copyright 2014-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-negative-feedback.png\" alt=\"(c) Copyright 2014-2021 Coert Vonk\" width=\"177\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-negative-feedback.png 343w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-negative-feedback-250x132.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-negative-feedback-300x158.png 300w\" sizes=\"(max-width: 343px) 100vw, 343px\" \/>\r\n            <\/a>\r\n            <figcaption>Oscillator<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    An implementation using inverters and a RC circuit is shown below.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/multivibrator6.png\">\r\n                <img class=\"wp-image-3884\" title=\"(c) Copyright 2014-2021 Coert Vonk\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/multivibrator6.png\" alt=\"(c) Copyright 2014-2021 Coert Vonk\" width=\"171\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/multivibrator6.png 351w, https:\/\/coert.vonk.one\/wp-content\/uploads\/multivibrator6-250x195.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/multivibrator6-300x234.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/multivibrator6-350x273.png 350w\" sizes=\"(max-width: 351px) 100vw, 351px\" \/>\r\n            <\/a>\r\n            <figcaption>Oscillator using RC circuit<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    The functionality can be explained as follows:\r\n    <ul>\r\n        <li>Suppose initially:\r\n        <ul>\r\n            <li>output U<sub>3<\/sub>=0V (a logical <code>0<\/code>), and<\/li>\r\n            <li>the capacitor is not charged .\u00b7. U<sub>1<\/sub>=U<sub>3<\/sub><\/li>\r\n        <\/ul>\r\n        <\/li>\r\n        <li>0\u21921:\r\n        <ul>\r\n            <li>The capacitor charges through resistor <em>R<\/em> .\u00b7. U<sub>1<\/sub> increases towards 5V.<\/li>\r\n            <li>Once U<sub>1<\/sub>\u22652V (the <code>1<\/code> threshold) .\u00b7. U<sub>2<\/sub> becomes 0V .\u00b7. output U<sub>3<\/sub> becomes 5V (a logical <code>1<\/code>)<\/li>\r\n        <\/ul>\r\n        <\/li>\r\n        <li>1\u21920:\r\n        <ul>\r\n            <li>The capacitor charge reverses through the resistor R .\u00b7. U<sub>1<\/sub> decreases towards 0V.<\/li>\r\n            <li>Once U<sub>1<\/sub>\u22640.7V (the <code>0<\/code> threshold) .\u00b7. U<sub>2<\/sub> becomes 5V .\u00b7. output U<sub>3<\/sub> becomes 0V (a logical <code>0<\/code>), and the cycle repeats itself.<\/li>\r\n        <\/ul>\r\n        <\/li>\r\n    <\/ul>\r\n<\/p>\r\n\r\n<h3>\r\n    Hands On\r\n<\/h3>\r\n\r\n<p>\r\n    <ul>\r\n        <li>D latch, Yenka Technology, Digital Electronics, build d-latch using gates, use models for d-type flip-flip, binary counter<\/li>\r\n        <li>Build or simulate a set-reset latch using NOR gates. (see Digital logic projects, page 27)<\/li>\r\n        <li>Build or simulate a D-latch using NAND gates. (see Digital logic projects, page 6)<\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    The <a href=\"\/hw\/logic\/programmable-logic-30714\">following chapter<\/a> introduces programmable logic that allows us to build more dense and flexible hardware systems.\r\n<\/p>\r\n","protected":false},"excerpt":{"rendered":"Introduces synchronous sequential logic.","protected":false},"author":41,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"_mi_skip_tracking":false},"categories":[303],"tags":[475,304],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v18.7 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Synchronous sequential - Coert Vonk<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Synchronous sequential - Coert Vonk\" \/>\n<meta property=\"og:description\" content=\"Introduces synchronous sequential logic.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712\" \/>\n<meta property=\"og:site_name\" content=\"Coert Vonk\" \/>\n<meta property=\"article:published_time\" content=\"2010-10-20T23:23:20+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-05-03T19:59:45+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png\" \/>\n<meta name=\"twitter:card\" content=\"summary\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Coert Vonk\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"5 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebSite\",\"@id\":\"https:\/\/coert.vonk.one\/#website\",\"url\":\"https:\/\/coert.vonk.one\/\",\"name\":\"Coert Vonk\",\"description\":\"Embedded Software Engineer\",\"publisher\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/coert.vonk.one\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage\",\"url\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png\",\"contentUrl\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png\",\"width\":354,\"height\":134,\"caption\":\"own work\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage\",\"url\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712\",\"name\":\"Synchronous sequential - Coert Vonk\",\"isPartOf\":{\"@id\":\"https:\/\/coert.vonk.one\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage\"},\"datePublished\":\"2010-10-20T23:23:20+00:00\",\"dateModified\":\"2022-05-03T19:59:45+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Vonk Family\",\"item\":\"https:\/\/coert.vonk.one\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Hardware\",\"item\":\"https:\/\/coert.vonk.one\/category\/hw\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"Logic (Verilog)\",\"item\":\"https:\/\/coert.vonk.one\/category\/hw\/logic\"},{\"@type\":\"ListItem\",\"position\":4,\"name\":\"Synchronous sequential\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#article\",\"isPartOf\":{\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage\"},\"author\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"headline\":\"Synchronous sequential\",\"datePublished\":\"2010-10-20T23:23:20+00:00\",\"dateModified\":\"2022-05-03T19:59:45+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage\"},\"wordCount\":835,\"publisher\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"image\":{\"@id\":\"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage\"},\"thumbnailUrl\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png\",\"keywords\":[\"logic\",\"verilog\"],\"articleSection\":[\"Logic (Verilog)\"],\"inLanguage\":\"en-US\"},{\"@type\":[\"Person\",\"Organization\"],\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\",\"name\":\"Coert Vonk\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/image\/\",\"url\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"contentUrl\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"caption\":\"Coert Vonk\"},\"logo\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/image\/\"},\"description\":\"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.\",\"sameAs\":[\"https:\/\/coert.vonk.one\"],\"url\":\"https:\/\/coert.vonk.one\/author\/cvonk\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Synchronous sequential - Coert Vonk","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712","og_locale":"en_US","og_type":"article","og_title":"Synchronous sequential - Coert Vonk","og_description":"Introduces synchronous sequential logic.","og_url":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712","og_site_name":"Coert Vonk","article_published_time":"2010-10-20T23:23:20+00:00","article_modified_time":"2022-05-03T19:59:45+00:00","og_image":[{"url":"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png"}],"twitter_card":"summary","twitter_misc":{"Written by":"Coert Vonk","Est. reading time":"5 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebSite","@id":"https:\/\/coert.vonk.one\/#website","url":"https:\/\/coert.vonk.one\/","name":"Coert Vonk","description":"Embedded Software Engineer","publisher":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/coert.vonk.one\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage","url":"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png","contentUrl":"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png","width":354,"height":134,"caption":"own work"},{"@type":"WebPage","@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage","url":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712","name":"Synchronous sequential - Coert Vonk","isPartOf":{"@id":"https:\/\/coert.vonk.one\/#website"},"primaryImageOfPage":{"@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage"},"datePublished":"2010-10-20T23:23:20+00:00","dateModified":"2022-05-03T19:59:45+00:00","breadcrumb":{"@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Vonk Family","item":"https:\/\/coert.vonk.one\/"},{"@type":"ListItem","position":2,"name":"Hardware","item":"https:\/\/coert.vonk.one\/category\/hw"},{"@type":"ListItem","position":3,"name":"Logic (Verilog)","item":"https:\/\/coert.vonk.one\/category\/hw\/logic"},{"@type":"ListItem","position":4,"name":"Synchronous sequential"}]},{"@type":"Article","@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#article","isPartOf":{"@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage"},"author":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"headline":"Synchronous sequential","datePublished":"2010-10-20T23:23:20+00:00","dateModified":"2022-05-03T19:59:45+00:00","mainEntityOfPage":{"@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#webpage"},"wordCount":835,"publisher":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"image":{"@id":"https:\/\/coert.vonk.one\/hw\/logic\/synchronous-sequential-logic-30712#primaryimage"},"thumbnailUrl":"https:\/\/coert.vonk.one\/wp-content\/uploads\/sequential-combinational-settling.png","keywords":["logic","verilog"],"articleSection":["Logic (Verilog)"],"inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e","name":"Coert Vonk","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/image\/","url":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","contentUrl":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","caption":"Coert Vonk"},"logo":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/image\/"},"description":"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.","sameAs":["https:\/\/coert.vonk.one"],"url":"https:\/\/coert.vonk.one\/author\/cvonk"}]}},"_links":{"self":[{"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/posts\/30712"}],"collection":[{"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/users\/41"}],"replies":[{"embeddable":true,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/comments?post=30712"}],"version-history":[{"count":7,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/posts\/30712\/revisions"}],"predecessor-version":[{"id":32973,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/posts\/30712\/revisions\/32973"}],"wp:attachment":[{"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/media?parent=30712"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/categories?post=30712"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/coert.vonk.one\/wp-json\/wp\/v2\/tags?post=30712"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}