{"id":30975,"date":"2011-12-04T17:36:22","date_gmt":"2011-12-05T01:36:22","guid":{"rendered":"https:\/\/coert.vonk.one\/?p=30975"},"modified":"2022-02-06T17:21:57","modified_gmt":"2022-02-07T01:21:57","slug":"implementation","status":"publish","type":"post","link":"/\/inquiries\/how-cpu-work\/implementation-30975","title":{"rendered":"Implementation"},"content":{"rendered":"<p>\r\n    Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.\r\n<\/p>\r\n<h2>\r\n    Implementation\r\n<\/h2>\r\n<p>\r\n    One dark Oregon winter afternoon, I said &#8220;Let&#8217;s build a micro processor&#8221;.  What started as a noble thought became a rather intense but fun project.\r\n<\/p>\r\n<p>\r\n    This section describes the implementation of the LC-3 using a Field Programmable Logic Array.  An FPGA is an array blocks with basic functionality such as Lookup table, a full adder and a flip-flop.  For more information on FPGAs refer to the section Programmable Logic in the inquiry &#8220;<a href=\"https:\/\/coert.vonk.one\/inquiries\/computer-math\/electrical-circuits-4245\">How do computers do math?<\/a>&#8220;.\r\n<\/p>\r\n<p>\r\n    The FPGA used to implement the LC-3 microprocessor is a Xilinx Spartan6, but others will fit equally well.  My choice was inspired by the pricing of the development board and the fairly good free development tools.  Other choices would be Altera for the FPGA, their IDE or Icarus Verilog for the synthesizer and simulator and GTKWave for the waveform viewer.  Refer to the end of this article for links and references to introductory Verilog books.\r\n<\/p>\r\n\r\n<h3>\r\n    Schematic\r\n<\/h3>\r\n<p>\r\n    The top level schematic is shown below.  The modules are defined using Verilog, an hardware description language (HDL) used to model digital logic.\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/lc3-schematic2.png\">\r\n                <img class=\"alignnone wp-image-4178\"  title=\"\"  src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2.png\" alt=\"\" width=\"600\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2.png 1337w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-400x310.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-768x595.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-1024x793.png 1024w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-250x194.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-300x232.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-350x271.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-500x387.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-schematic2-750x581.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 schematic<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    This is my first Verilog implementation, please bear with me ..\r\n<\/p>\r\n\r\n<h3>\r\n    State\r\n<\/h3>\r\n\r\n<h4>\r\n    State.v\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, source file <code>State.v<\/code>:\r\n\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\"> cCtrl,      \/\/ controller control signal\r\n                input eREADY,           \/\/ external memory ready signal\r\n                output wire pEn,        \/\/ update PC enable\r\n                output wire fEn,        \/\/ fetch output enable\r\n                output wire dEn,        \/\/ decode enable\r\n                output wire [2:0] mOp,  \/\/ memory operation selector\r\n                output wire rWe );      \/\/ register write enable\r\n\r\n    `include &quot;UpdatePC.vh&quot;\r\n    `include &quot;Fetch.vh&quot;\r\n    `include &quot;Decode.vh&quot;\r\n    `include &quot;Registers.vh&quot;\r\n    `include &quot;MemoryIF.vh&quot;\r\n\r\n    parameter [3:0] STATE_UPDATEPC = 4'd0,   \/\/ update program counter\r\n                    STATE_FETCH    = 4'd1,   \/\/ fetch instruction\r\n                    STATE_DECODE   = 4'd2,   \/\/ decode\r\n                    STATE_ALU      = 4'd3,   \/\/ ALU\r\n                    STATE_ADDRNPC  = 4'd4,   \/\/ calc tPC address\r\n                    STATE_ADDRMEM  = 4'd5,   \/\/ calc memory address\r\n                    STATE_INDMEM   = 4'd6,   \/\/ indirect memory address\r\n                    STATE_RDMEM    = 4'd7,   \/\/ read memory\r\n                    STATE_WRMEM    = 4'd8,   \/\/ write memory\r\n                    STATE_WRREG    = 4'd9,   \/\/ write register\r\n                    STATE_ILLEGAL  = 4'd15;  \/\/ illegal state\r\n\r\n    parameter       EREADY_INA     = 1'b0,   \/\/ external memory not ready\r\n                    EREADY_ACT     = 1'b1,   \/\/ external memory ready\r\n                    EREADY_X       = 1'bx;\r\n\r\n    wire [1:0] iType   = cCtrl[4:3];  \/\/ instruction type (00=alu, 01=ctrl, 10=mem)\r\n    wire [1:0] maType  = cCtrl[2:1];  \/\/ memory access type (00=indaddr, 01=read, 02=write, 03=updreg)\r\n    wire       indType = cCtrl[0];    \/\/ indirect memory access type\r\n\r\n    reg [3:0] state;   \/\/ current state\r\n    reg [3:0] nState;  \/\/ next state\r\n    reg [6:0] out;     \/\/ current output signals\r\n    reg [6:0] nOut;    \/\/ next output signals\r\n\r\n    assign pEn = out[6];\r\n    assign fEn = out[5];\r\n    assign dEn = out[4];\r\n    assign mOp = out[3:1];\r\n    assign rWe = out[0];\r\n\r\n        \/\/ the combinational logic\r\n\r\n    always @(state, eREADY, iType, maType, indType, state, out)\r\n        casex ({state, eREADY, iType, maType, indType})\r\n        {STATE_UPDATEPC, EREADY_X,   ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_FETCH;    nOut = {PEN_0, FEN_1, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_FETCH,    EREADY_ACT, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_DECODE;   nOut = {PEN_0, FEN_0, DEN_1, MOP_NONE, RWE_0}; end\r\n            {STATE_DECODE,   EREADY_X,   ITYPE_ALU, MATYPE_X,   INDTYPE_X}  : begin nState = STATE_ALU;      nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_DECODE,   EREADY_X,   ITYPE_CTL, MATYPE_X,   INDTYPE_X}  : begin nState = STATE_ADDRNPC;  nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_DECODE,   EREADY_X,   ITYPE_MEM, MATYPE_X,   INDTYPE_X}  : begin nState = STATE_ADDRMEM;  nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_ADDRMEM,  EREADY_X,   ITYPE_X,   MATYPE_IND, INDTYPE_X}  : begin nState = STATE_INDMEM;   nOut = {PEN_0, FEN_0, DEN_0, MOP_RD,   RWE_0}; end\r\n        {STATE_ADDRMEM,  EREADY_X,   ITYPE_X,   MATYPE_RD,  INDTYPE_X}  : begin nState = STATE_RDMEM;    nOut = {PEN_0, FEN_0, DEN_0, MOP_RD,   RWE_0}; end\r\n        {STATE_INDMEM,   EREADY_ACT, ITYPE_X,   MATYPE_X,   INDTYPE_RD} : begin nState = STATE_RDMEM;    nOut = {PEN_0, FEN_0, DEN_0, MOP_RDI,  RWE_0}; end\r\n        {STATE_ADDRMEM,  EREADY_X,   ITYPE_X,   MATYPE_WR,  INDTYPE_X}  : begin nState = STATE_WRMEM;    nOut = {PEN_0, FEN_0, DEN_0, MOP_WR,   RWE_0}; end\r\n        {STATE_INDMEM,   EREADY_ACT, ITYPE_X,   MATYPE_X,   INDTYPE_WR} : begin nState = STATE_WRMEM;    nOut = {PEN_0, FEN_0, DEN_0, MOP_WR,   RWE_0}; end\r\n        {STATE_ALU,      EREADY_X,   ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_WRREG;    nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_1}; end\r\n        {STATE_ADDRMEM,  EREADY_X,   ITYPE_X,   MATYPE_REG, INDTYPE_X}  : begin nState = STATE_WRREG;    nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_1}; end\r\n        {STATE_RDMEM,    EREADY_ACT, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_WRREG;    nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_1}; end\r\n        {STATE_WRMEM,    EREADY_ACT, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_UPDATEPC; nOut = {PEN_1, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_WRREG,    EREADY_X,   ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_UPDATEPC; nOut = {PEN_1, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_ADDRNPC,  EREADY_X,   ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = STATE_UPDATEPC; nOut = {PEN_1, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        {STATE_FETCH,    EREADY_INA, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = state;          nOut = out;                                    end\r\n        {STATE_INDMEM,   EREADY_INA, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = state;          nOut = out;                                    end\r\n        {STATE_RDMEM,    EREADY_INA, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = state;          nOut = out;                                    end\r\n        {STATE_WRMEM,    EREADY_INA, ITYPE_X,   MATYPE_X,   INDTYPE_X}  : begin nState = state;          nOut = out;                                    end\r\n        default                                                         : begin nState = STATE_ILLEGAL;  nOut = {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_0}; end\r\n        endcase\r\n\r\n        \/\/ the sequential logic\r\n\r\n    always @(negedge clock, posedge reset)\r\n    if (reset)\r\n        begin\r\n            state &lt;= STATE_UPDATEPC;\r\n            out &lt;= {PEN_0, FEN_0, DEN_0, MOP_NONE, RWE_0};\r\n        end\r\n    else\r\n    begin\r\n        state &lt;= nState;\r\n        out &lt;= nOut;\r\n        end;\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    Decode\r\n<\/h3>\r\n\r\n<h4>\r\n    Decode.vh\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, header file <code>Decode.vh<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter       DEN_0          = 1'b0,   \/\/ Decode enable\r\n                DEN_1          = 1'b1;\r\n\r\nparameter [1:0] ITYPE_ALU      = 2'b00,  \/\/ generalized instruction type\r\n                ITYPE_CTL      = 2'b01,\r\n                ITYPE_MEM      = 2'b10,\r\n                ITYPE_HLT      = 2'b11,\r\n                ITYPE_X        = 2'bxx;\r\n\r\nparameter [1:0] MATYPE_IND     = 2'b00,  \/\/ generalized memory access type\r\n                MATYPE_RD      = 2'b01,\r\n                MATYPE_WR      = 2'b10,\r\n                MATYPE_REG     = 2'b11,\r\n                MATYPE_X       = 2'bxx;\r\n\r\nparameter       INDTYPE_WR     = 1'b0,   \/\/ generalized memory indirection type\r\n                INDTYPE_RD     = 1'b1,\r\n                INDTYPE_X      = 1'bx;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    Decode.v\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, source file <code>Decode.v<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module Decode( input clock,\r\n                input reset,\r\n                input en,                   \/\/ input enable\r\n                input [15:0] eDIN,          \/\/ external memory data input\r\n                input [2:0] psr,            \/\/ processor status register\r\n                output [4:0] cCtrl,         \/\/ various control signals\r\n                output [1:0] drSrc,         \/\/ selects what to write to DR\r\n                output [2:0] uOp,           \/\/ selecta ALU operation\r\n                output aOp,                 \/\/ selects Address operation\r\n                output pNext,               \/\/ selects if PC should branch\r\n                output [2:0] sr1ID,         \/\/ source register 1 ID\r\n                output [2:0] sr2ID,         \/\/ source register 2 ID\r\n                output [2:0] drID,          \/\/ destination register ID\r\n                output wire [4:0] imm,      \/\/ lower 5 bits from IR value\r\n                output wire [8:0] offset ); \/\/ lower 9 bits from IR value\r\n\r\n    `include &quot;ALU.vh&quot;\r\n    `include &quot;Address.vh&quot;\r\n    `include &quot;MemoryIF.vh&quot;\r\n    `include &quot;DrMux.vh&quot;\r\n    `include &quot;UpdatePC.vh&quot;\r\n    `include &quot;Decode.vh&quot;\r\n\r\n    parameter [2:0] ID_X = 3'bxxx;\r\n\r\n        \/\/ Instruction Register (ir)\r\n        \/\/ read instruction from external memory bus (after Fetch initiated the bus cycle)\r\n\r\n    reg [15:0] ir;\r\n    assign imm    = ir[4:0];  \/\/ output the lower 5 bits\r\n    assign offset = ir[8:0];  \/\/ output the lower 9 bits\r\n\r\n    always @(posedge clock, posedge reset)\r\n    if (reset)\r\n        ir = 16'hffff;\r\n        else\r\n        if (en == DEN_1)\r\n            ir = eDIN;\r\n\r\n    parameter [3:0]           \/\/ opcodes for the instructions\r\n        I_BR  = 4'b0000,\r\n        I_ADD = 4'b0001,\r\n        I_LD  = 4'b0010,\r\n        I_ST  = 4'b0011,\r\n        I_AND = 4'b0101,\r\n        I_LDR = 4'b0110,\r\n        I_STR = 4'b0111,\r\n        I_NOT = 4'b1001,\r\n        I_LDI = 4'b1010,\r\n        I_STI = 4'b1011,\r\n        I_JMP = 4'b1100,\r\n        I_LEA = 4'b1110,\r\n        I_HLT = 4'b1111;\r\n\r\n    reg [20:0] ctl;           \/\/ current control signal bundle\r\n\r\n        \/\/ untangle control signal bundle\r\n\r\n    assign cCtrl = ctl[ 20:16 ];  \/\/ { iType, maType, indRd }\r\n    assign uOp   = ctl[ 15:13 ];\r\n    assign aOp   = ctl[    12 ];\r\n    assign drSrc = ctl[ 11:10 ];\r\n    assign pNext = ctl[     9 ];\r\n    assign drID  = ctl[  8: 6 ];\r\n    assign sr1ID = ctl[  5: 3 ];\r\n    assign sr2ID = ctl[  2: 0 ];\r\n\r\n        \/\/ combinational logic to determine control signals\r\n\r\n    wire [2:0] uOpAddC = (ir[5]) ? UOP_ADDIMM : UOP_ADDREG;         \/\/ candidate for uOp in case of ADD instruction\r\n    wire [2:0] uOpAndC = (ir[5]) ? UOP_ANDIMM : UOP_ANDREG;         \/\/ candidate for uOp in case of AND instruction\r\n    wire pNextC        = |(ir[11:9] &amp; psr) ? PNEXT_TPC : PNEXT_NPC; \/\/ candidate for pNext in case of BR instruction\r\n\r\n    always @(ir[15:12], uOpAddC, uOpAndC, pNextC)\r\n                    \/\/ State      State       State       ALU      Address  DrSource    UpdatePC   Registers RegistersRegisters\r\n    case (ir[15:12])\/\/ iType      maType      indType     uOp      aOp      drSrc       pNext      drID      sr1ID    sr2ID\r\n        I_ADD   : ctl = {ITYPE_ALU, MATYPE_X,   INDTYPE_X,  uOpAddC, AOP_X,   DRSRC_ALU,  PNEXT_NPC, ir[11:9], ir[8:6], ir[2:0] };\r\n        I_AND   : ctl = {ITYPE_ALU, MATYPE_X,   INDTYPE_X,  uOpAndC, AOP_X,   DRSRC_ALU,  PNEXT_NPC, ir[11:9], ir[8:6], ir[2:0] };\r\n        I_NOT   : ctl = {ITYPE_ALU, MATYPE_X,   INDTYPE_X,  UOP_NOT, AOP_X,   DRSRC_ALU,  PNEXT_NPC, ir[11:9], ir[8:6], ID_X    };\r\n        I_BR    : ctl = {ITYPE_CTL, MATYPE_X,   INDTYPE_X,  UOP_X,   AOP_NPC, DRSRC_X,    pNextC,    ID_X,     ID_X,    ID_X    };\r\n        I_JMP   : ctl = {ITYPE_CTL, MATYPE_X,   INDTYPE_X,  UOP_X,   AOP_SR1, DRSRC_X,    PNEXT_TPC, ID_X,     ir[8:6], ID_X    };\r\n        I_LD    : ctl = {ITYPE_MEM, MATYPE_RD,  INDTYPE_X,  UOP_X,   AOP_NPC, DRSRC_MEM,  PNEXT_NPC, ir[11:9], ID_X,    ID_X    };\r\n        I_LDR   : ctl = {ITYPE_MEM, MATYPE_RD,  INDTYPE_X,  UOP_X,   AOP_SR1, DRSRC_MEM,  PNEXT_NPC, ir[11:9], ir[8:6], ID_X    };\r\n        I_LDI   : ctl = {ITYPE_MEM, MATYPE_IND, INDTYPE_RD, UOP_X,   AOP_NPC, DRSRC_MEM,  PNEXT_NPC, ir[11:9], ID_X,    ID_X    };\r\n        I_LEA   : ctl = {ITYPE_MEM, MATYPE_REG, INDTYPE_X,  UOP_X,   AOP_NPC, DRSRC_ADDR, PNEXT_NPC, ir[11:9], ID_X,    ID_X    };\r\n        I_ST    : ctl = {ITYPE_MEM, MATYPE_WR,  INDTYPE_X,  UOP_X,   AOP_NPC, DRSRC_X,    PNEXT_NPC, ID_X,     ID_X,    ir[11:9]};\r\n        I_STR   : ctl = {ITYPE_MEM, MATYPE_WR,  INDTYPE_X,  UOP_X,   AOP_SR1, DRSRC_X,    PNEXT_NPC, ID_X,     ir[8:6], ir[11:9]};\r\n        I_STI   : ctl = {ITYPE_MEM, MATYPE_IND, INDTYPE_WR, UOP_X,   AOP_NPC, DRSRC_X,    PNEXT_NPC, ID_X,     ID_X,    ir[11:9]};\r\n        default : ctl = {ITYPE_HLT, MATYPE_X,   INDTYPE_X,  UOP_X,   AOP_X,   DRSRC_X,    PNEXT_X,   ID_X,     ID_X,    ID_X    };\r\n    endcase \r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    UpdatePC\r\n<\/h3>\r\n\r\n<h4>\r\n    UpdatePC.vh\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, header file <code>UpdatePC.vh<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter PNEXT_NPC  = 1'b0,  \/\/ UpdatePC branch signal\r\n            PNEXT_TPC  = 1'b1,\r\n            PNEXT_X    = 1'bx;\r\n\r\nparameter PEN_0      = 1'b0,  \/\/ UpdatePC enable\r\n            PEN_1      = 1'b1;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    UpdatePC.v\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, source file <code>UpdatePC.v<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module UpdatePC( input clock,\r\n                    input reset,\r\n                    input en,                 \/\/ enable signal\r\n                    input [15:0] tPC,         \/\/ target program counter\r\n                    input pNext,              \/\/ if 1 then branch to tPC\r\n                    output reg [15:0] pc,     \/\/ program counter\r\n                    output reg [15:0] nPC );  \/\/ next program counter (pc+1)\r\n\r\n    `include &quot;UpdatePC.vh&quot;\r\n\r\n    wire [15:0] a = (pNext) ? tPC : nPC;     \/\/ if pNext==1, then jump to tPC\r\n    wire [15:0] b = (en == PEN_1) ? a : pc;  \/\/ change PC only in &quot;Update PC&quot; state\r\n    wire [15:0] c = b + 1'b1;                \/\/ use carry input\r\n\r\n    always @(posedge clock, posedge reset)\r\n    if (reset)\r\n        begin\r\n            pc  &lt;= 16'h3000;\r\n            nPC &lt;= 16'h3001;\r\n        end\r\n    else\r\n        begin\r\n        pc  &lt;= b;\r\n        nPC &lt;= c;\r\n        end;\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    Fetch\r\n<\/h3>\r\n\r\n<h4>\r\n    Fetch.vh\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, header file <code>Fetch.vh<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter FEN_0 = 1'b0,  \/\/ fetch enable\r\n            FEN_1 = 1'b1;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    Fetch.v\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, source file <code>Fetch.v<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module Fetch( input en,                 \/\/ output enable\r\n                input [15:0] pc,          \/\/ program counter\r\n                    output reg iBR,           \/\/ internal memory address lines\r\n                    output reg [15:0] iADDR,  \/\/ internal memory address lines\r\n                output reg iWEA );        \/\/ internal memory write enable\r\n\r\n    `include &quot;Fetch.vh&quot;\r\n\r\n    always @(en, pc)\r\n    begin\r\n        iBR   &lt;= ( en == FEN_1 ) ? 1'b1 : 1'b0;\r\n        iADDR &lt;= ( en == FEN_1 ) ? pc : 16'hxxxx;\r\n        iWEA  &lt;= ( en == FEN_1 ) ? 1'b0 : 1'bx;\r\n    end\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    Registers\r\n<\/h3>\r\n\r\n<h4>\r\n    Registers.vh\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, header file <code>Registers.vh<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter       RWE_0 = 1'b0,           \/\/ register write enable\r\n                RWE_1 = 1'b1;\r\n\r\nparameter [2:0] PSR_POSITIVE = 3'b001,  \/\/ processor status register bits\r\n                PSR_ZERO     = 3'b010,  \/\/   should match BR instruction\r\n                PSR_NEGATIVE = 3'b100;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    Registers.v\r\n<\/h4>\r\n\r\n<p>\r\n    Implementation of the LC-3 instruction set in Verilog, source file <code>Registers.v<\/code>:\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module Registers( input clock,\r\n                  input reset,\r\n                  input we,                \/\/ write enable\r\n                  input [2:0] sr1ID,       \/\/ source register 1 ID\r\n                  input [2:0] sr2ID,       \/\/ source register 2 ID\r\n                  input [2:0] drID,        \/\/ destination register ID\r\n                  input [15:0] dr,         \/\/ destination register value\r\n                  output reg [15:0] sr1,   \/\/ source register 1 value\r\n                  output reg [15:0] sr2,   \/\/ source register 2 value\r\n                  output reg [2:0] psr );  \/\/ processor status register\r\n\r\n    `include &quot;Registers.vh&quot;\r\n\r\n    reg [3:0] id;\r\n    reg [15:0] gpr [0:7];     \/\/ general purpose registers\r\n\r\n        \/\/ write the destination register value, and update Process Status Register (psr)\r\n\r\n    always @(posedge clock, posedge reset)\r\n    if (reset)\r\n        for (id = 0; id &lt; 7; id = id + 1)  \/\/ initial all registers to 0\r\n        gpr[ id ] &lt;= 16'h0000;\r\n    else\r\n        if (we == RWE_1)          \/\/ when enabled by the FSM\r\n            begin\r\n            if (dr[ 15 ])         \/\/ update processor status register (neg,zero,pos)\r\n            psr &lt;= PSR_NEGATIVE;\r\n            else if (|dr)\r\n            psr &lt;= PSR_POSITIVE;\r\n            else\r\n            psr &lt;= PSR_ZERO;\r\n\r\n                gpr[ drID ] &lt;= dr;     \/\/ write the value dr to the register identified by drID\r\n        end\r\n\r\n        \/\/ output the value of the register identified by &quot;sr1ID&quot; on output &quot;sr1&quot;\r\n        \/\/ output the value of the register identified by &quot;sr2ID&quot; on output &quot;sr2&quot;\r\n\r\n    always @(sr1ID, sr2ID, gpr[ sr1ID ], gpr[ sr2ID ])\r\n    begin\r\n        sr1 = gpr[ sr1ID ];\r\n        sr2 = gpr[ sr2ID ];\r\n    end\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    ALU\r\n<\/h3>\r\n                    \r\n<h4>\r\n    ALU.vh\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter [2:0] UOP_ADDREG = 3'b000,  \/\/ ALU operation\r\n                UOP_ADDIMM = 3'b001,\r\n                UOP_ANDREG = 3'b010,\r\n                UOP_ANDIMM = 3'b011,\r\n                UOP_NOT    = 3'b100,\r\n                UOP_X      = 3'bxxx;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    ALU.v\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module ALU( input [2:0] uOp,          \/\/ operation selector\r\n            input [15:0] sr1,         \/\/ source register 1 value (SR1)\r\n            input [15:0] sr2,         \/\/ source register 2 value (SR2)\r\n            input [4:0] imm,          \/\/ lower 5 bits from instruction register\r\n                output reg [15:0] uOut ); \/\/ result of ALU operation\r\n\r\n    `include &quot;ALU.vh&quot;\r\n\r\n    wire [15:0] imm5 = ({ {11{imm[4]}}, imm[4:0] });  \/\/ sign extend to 16 bits\r\n\r\n    always @(uOp or sr1 or sr2 or imm5)\r\n    casex (uOp)\r\n        3'b000: uOut = sr1 + sr2;   \/\/ ADD Mode 0\r\n        3'b001: uOut = sr1 + imm5;  \/\/ ADD Mode 1\r\n        3'b010: uOut = sr1 &amp; sr2;   \/\/ AND Mode 0\r\n        3'b011: uOut = sr1 &amp; imm5;  \/\/ AND Mode 1\r\n        3'b1xx: uOut = ~(sr1);      \/\/ NOT\r\n    endcase\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    Address\r\n<\/h3>\r\n\r\n<h4>\r\n    Address.vh\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter AOP_SR1 = 1'b0,  \/\/ address operation\r\n          AOP_NPC = 1'b1,\r\n          AOP_X   = 1'bx;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    Address.v\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module Address( input aOp,                \/\/ operation selector\r\n                input [15:0] sr1,         \/\/ value source register 1\r\n                input [15:0] nPC,         \/\/ next program counter (PC), always PC+1\r\n                input [8:0] offset,       \/\/ lower 9 bits from instruction register\r\n                output reg [15:0] aOut ); \/\/ target program counter\r\n\r\n    `include &quot;Address.vh&quot;\r\n\r\n    wire [15:0] offset6 = ({{10{offset[5]}}, offset[5:0]});  \/\/ sign extended the 6-bit offset\r\n    wire [15:0] offset9 = ({{ 7{offset[8]}}, offset[8:0]});  \/\/ sign extended the 9-bit offset\r\n\r\n    always @(aOp or sr1 or nPC or offset6 or offset9)\r\n    case (aOp)\r\n        AOP_SR1 : aOut = sr1 + offset6;  \/\/ register + offset\r\n        AOP_NPC : aOut = nPC + offset9;  \/\/ next PC  + offset\r\n    endcase\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    MemoryIF\r\n<\/h3>\r\n\r\n<h4>\r\n    MemoryIF.vh\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter [2:0] MOP_NONE = 3'b000,  \/\/ MemoryIF operation\r\n                MOP_RD   = 3'b100,\r\n                MOP_RDI  = 3'b101,\r\n                MOP_WR   = 3'b110,\r\n                MOP_WRI  = 3'b111;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    MemoryIF.v\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module MemoryIF( input [2:0] mOp,         \/\/ memory operation selector\r\n                 input [15:0] sr2,        \/\/ source register 2 value\r\n                 input [15:0] addr,       \/\/ address for read or write\r\n                 input [15:0] eDIN,       \/\/ external memory data input\r\n                 output reg iBR,          \/\/ internal bus request\r\n                 output reg [15:0] iADDR, \/\/ internal memory address lines\r\n                 output tri [15:0] eDOUT, \/\/ internal memory data output\r\n                 output reg iWEA );       \/\/ internal memory write enable\r\n\r\n    `include &quot;MemoryIF.vh&quot;\r\n\r\n    reg [15:0] eDOUTr;\r\n    assign eDOUT = eDOUTr;\r\n\r\n    always @(mOp, sr2, addr, eDIN)\r\n    case (mOp)\r\n        MOP_RD  : begin iBR=1; iWEA = 1'b0; iADDR = addr;     eDOUTr = 16'hzzzz; end\r\n        MOP_RDI : begin iBR=1; iWEA = 1'b0; iADDR = eDIN;     eDOUTr = 16'hzzzz; end\r\n        MOP_WR  : begin iBR=1; iWEA = 1'b1; iADDR = addr;     eDOUTr = sr2;      end\r\n        MOP_WRI : begin iBR=1; iWEA = 1'b1; iADDR = eDIN;     eDOUTr = sr2;      end\r\n        default : begin iBR=0; iWEA = 1'bx; iADDR = 16'hxxxx; eDOUTr = 16'hzzzz; end\r\n    endcase\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    DrMux\r\n<\/h3>\r\n\r\n<h4>\r\n    DrMux.vh\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">parameter [1:0] DRSRC_ALU  = 2'b00,  \/\/ destination register source selector\r\n                DRSRC_MEM  = 2'b01,\r\n                DRSRC_ADDR = 2'b10,\r\n                DRSRC_X    = 2'bxx;<\/pre>\r\n<\/p>\r\n\r\n<h4>\r\n    DrMux.v\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module DrMux( input [1:0] drSrc,       \/\/ multiplexor selector\r\n              input [15:0] eDIN,       \/\/ external memory data input\r\n              input [15:0] addr,       \/\/ effective memory address\r\n              input [15:0] uOut,       \/\/ result from ALU\r\n              output reg [15:0] dr );  \/\/ data that will be stored in DR\r\n\r\n    `include &quot;DrMux.vh&quot;\r\n\r\n    always @(drSrc or uOut or eDIN or addr)\r\n    case (drSrc)\r\n        DRSRC_ALU  : dr = uOut;\r\n        DRSRC_MEM  : dr = eDIN;\r\n        DRSRC_ADDR : dr = addr;\r\n        default    : dr = 16'hxxxx;\r\n    endcase\r\n\r\nendmodule:<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    BusDriver\r\n<\/h3>\r\n\r\n<h4>\r\n    BusDriver.v\r\n<\/h4>\r\n\r\n<p>\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">module BusDriver( input br0,                \/\/ input 0, bus request\r\n                    input [15:0] iADDR0,      \/\/ input 0, internal memory address lines\r\n                        input iWEA0,              \/\/ input 0, internal memory write enable\r\n                    input br1,                \/\/ input 1, bus request\r\n                    input [15:0] iADDR1,      \/\/ input 1, internal memory address lines\r\n                        input iWEA1,              \/\/ input 1, internal memory write enable\r\n                    output tri [15:0] eADDR,  \/\/ external memory address lines\r\n                        output tri  eWEA );       \/\/ external memory write enable\r\n\r\n    assign eWEA  = br1 ? iWEA1 :\r\n                    br0 ? iWEA0 : 1'bz;\r\n\r\n    assign eADDR = br1 ? iADDR1 :\r\n                    br0 ? iADDR0 : 16'hzzzz;\r\n\r\nendmodule<\/pre>\r\n<\/p>\r\n\r\n<h2>\r\n    Functional simulation\r\n<\/h2>\r\n\r\n<p>\r\n    The functionality of our microprocessor can be tested by building a test bench.  The bench will supply the clock signal and reset pulse and simulate a random access memory (RAM) containing the test program.  The program is written using in a assembly language and compiled using <a href=\"https:\/\/highered.mheducation.com\/sites\/0072467509\/student_view0\/lc-3_simulator.html\">LC3Edit<\/a>.\r\n<\/p>\r\n\r\n<h3>\r\n    Test program\r\n<\/h3>\r\n\r\n<p>\r\n    Exercises a variety of instructions:\r\n    <ul>\r\n        <li>memory read<\/li>\r\n        <li>alu<\/li>\r\n        <li>memory write<\/li>\r\n        <li>control instructions<\/li>\r\n    <\/ul>\r\n<\/p>\r\n<p>\r\n    Written in assembly language\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/lc3-memory_asm.png\">\r\n                <img class=\"alignnone wp-image-4153\" title=\"lc3 memory_asm\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm.png\" alt=\"own work\" width=\"275\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm.png 359w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm-226x400.png 226w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm-141x250.png 141w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm-169x300.png 169w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm-198x350.png 198w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_asm-282x500.png 282w\" sizes=\"(max-width: 359px) 100vw, 359px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 memory asm<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    LC3Edit compiles this into the object file:\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/lc3-memory_obj.png\">\r\n                <img class=\"alignnone wp-image-4154\" title=\"lc3 memory_obj\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj.png\" alt=\"own work\" width=\"360\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj.png 423w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj-384x400.png 384w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj-240x250.png 240w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj-288x300.png 288w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_obj-336x350.png 336w\" sizes=\"(max-width: 423px) 100vw, 423px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 memory obj<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n<p>\r\n    As part of the compilation, LC3Edit also creates a <code>.hex<\/code> file.  The contents of this file can be tweaked into a <em>.coe<\/em> file to be preloaded in the test bench memory.\r\n\r\n    <div class=\"align-center\">\r\n        <figure>\r\n            <a class=\"hide-anchor fancybox\" href=\"\/wp-content\/uploads\/lc3-memory_coe2.png\">\r\n                <img class=\"alignnone wp-image-4156\" title=\"lc3 memory_coe2\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_coe2.png\" alt=\"own work\" width=\"350\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_coe2.png 381w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_coe2-250x71.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_coe2-300x85.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-memory_coe2-350x99.png 350w\" sizes=\"(max-width: 381px) 100vw, 381px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 Memory coe<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h3>\r\n    Memory\r\n<\/h3>\r\n\r\n<p>\r\n    The random access memory (RAM) is created using Xilinx IP&#8217;s Block Memory Generator 6.2.  The following parameters are used:\r\n    <ul>\r\n        <li>native i\/f, single port ram, no byte write enable, minimum area algorithm, width 16, depth 4096, write first, use ENA pin, no output registers, no RSTA pin, enable all warnings.  Initialize memory from the <code>.coe<\/code> file.<\/li>\r\n    <\/ul>\r\n<\/p>\r\n\r\n<h3>\r\n    Test bench and clock\/reset signals\r\n<\/h3>\r\n\r\n<p>\r\n    Generate a 50 MHz symmetric clock.\r\n<\/p>\r\n<p>\r\n    Integrate the parts into a test bench using Verilog.\r\n\r\n    <pre class=\"brush: verilog; gutter: true; title: ; toolbar: false; notranslate\" title=\"\">`timescale 1ns \/ 1ps\r\nmodule SimpleLC3_SimpleLC3_sch_tb();\r\n\r\n    reg clock;          \/\/ clock                        (generated by test fixture)\r\n    reg reset;          \/\/ reset                        (generated by test fixture)\r\n\r\n    wire [15:0] eADDR;  \/\/ external address             (from LC3 to memory)\r\n    wire [15:0] eDIN;   \/\/ external data                (from memory to LC3)\r\n    wire [15:0] eDOUT;  \/\/ external data                (from LC3 to memory)\r\n    wire eWEA;          \/\/ external write(~read) enable (from LC3 to memory)\r\n\r\n        \/\/ Instantiate the Unit Under Test\r\n    SimpleLC3 UUT ( .eDOUT(eDOUT),\r\n                    .eWEA(eWEA),\r\n                    .clock(clock),\r\n                    .eREADY(1'b1),  \/\/ ready (always 1, for now)\r\n                    .eDIN(eDIN),\r\n                    .reset(reset),\r\n                    .eADDR(eADDR) );\r\n\r\n        \/\/ Instantiate the Memory, created using Xilinx IP's Block Memory Generator 6.2:\r\n        \/\/ Initialize from memory.coe, created from compiling memory.asm using LC3Edit.\r\n    memory RAM( .clka(clock),\r\n                .ena(eENA),\r\n                .wea(eWEA),\r\n                .addra(eADDR[11:0]),\r\n                .dina(eDOUT),\r\n                .douta(eDIN) );\r\n\r\n    wire eENA = |(eADDR[15:12] == 4'h3);  \/\/ memory is at h3xxx\r\n\r\n    initial begin\r\n        clock = 0;\r\n        reset = 0;\r\n    #15 reset = 1;  \/\/ wait for global reset to finish\r\n        #22 reset = 0;\r\n    end\r\n\r\n    always\r\n    #10 clock &lt;= ~clock;  \/\/ 20 ns clock period (50 MHz)\r\n\r\nendmodule;<\/pre>\r\n<\/p>\r\n\r\n<h3>\r\n    Simulation results\r\n<\/h3>\r\n\r\n<p>\r\n    For the functional simulation we use ISim that comes bundled with the Xilinx IDE.\r\n<\/p>\r\n<p>\r\n    The simulation needs to be ran for 1600 ns.\r\n<\/p>\r\n<p>\r\n    Waveform diagrams are shown below (click to enlarge)\r\n\r\n    <div class=\"flex-container\">\r\n        <figure>\r\n            <a href=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld.png\">\r\n                <img loading=\"lazy\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld.png\" alt=\"LC3 Memory load\" width=\"1161\" height=\"694\" class=\"size-full wp-image-4163\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld.png 1161w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-400x239.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-768x459.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-1024x612.png 1024w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-250x149.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-300x179.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-350x209.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-500x299.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-ld-750x448.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 Memory load<\/figcaption>\r\n        <\/figure>\r\n        <figure>\r\n            <a href=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu.png\">\r\n                <img loading=\"lazy\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu.png\" alt=\"LC3 ALU operations\" width=\"831\" height=\"650\" class=\"size-full wp-image-4162\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu.png 831w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-400x313.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-768x601.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-250x196.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-300x235.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-350x274.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-500x391.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-alu-750x587.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 ALU operations<\/figcaption>\r\n        <\/figure>\r\n        <figure>\r\n            <a href=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st.png\">\r\n                <img loading=\"lazy\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st.png\" alt=\"LC3 Memory store\" width=\"849\" height=\"749\" class=\"size-full wp-image-4164\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st.png 849w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-400x353.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-768x678.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-250x221.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-300x265.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-350x309.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-500x441.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-st-750x662.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 Memory store<\/figcaption>\r\n        <\/figure>\r\n        <figure>\r\n            <a href=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control.png\">\r\n                <img loading=\"lazy\" src=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control.png\" alt=\"LC3 Control instructions\" width=\"1131\" height=\"712\" class=\"size-full wp-image-4165\" srcset=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control.png 1131w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-400x252.png 400w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-768x483.png 768w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-1024x645.png 1024w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-250x157.png 250w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-300x189.png 300w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-350x220.png 350w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-500x315.png 500w, https:\/\/coert.vonk.one\/wp-content\/uploads\/lc3-function-control-750x472.png 750w\" sizes=\"(max-width: 706px) 89vw, (max-width: 767px) 82vw, 740px\" \/>\r\n            <\/a>\r\n            <figcaption>LC3 Control instructions<\/figcaption>\r\n        <\/figure>\r\n    <\/div>\r\n<\/p>\r\n\r\n<h3>\r\n    Timing simulation\r\n<\/h3>\r\n\r\n<p>\r\n    The free Xilinx IDE doesn&#8217;t support timing simulations.  Instead we will use <a href=\"https:\/\/iverilog.fandom.com\/wiki\/User_Guide\">Icarus Verilog<\/a> for the synthesis and simulation, <a href=\"http:\/\/gtkwave.sourceforge.net\/\">GTKWave<\/a> for viewing the generated waveforms, and Emacs <a href=\"https:\/\/www.verilog.com\/verilog-mode.html\">verilog-mode<\/a> for editing.  We will run them natively under Linux.  For those interested, Windows binaries are available from <a href=\"http:\/\/bleyer.org\/icarus\/\">bleyer.org<\/a>.\r\n<\/p>\r\n<p>\r\n  This concludes the &#8220;Implementation of the LC-3 instruction set in Verilog&#8221;.\r\n<\/p>\r\n","protected":false},"excerpt":{"rendered":"Chapter 4. Shows an implementation of the LC-3 instruction set in Verilog HDL.","protected":false},"author":41,"featured_media":6678,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"_mi_skip_tracking":false},"categories":[418],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v18.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Implementation of the LC-3 instruction set in Verilog - Coert Vonk<\/title>\n<meta name=\"description\" content=\"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Implementation of the LC-3 instruction set in Verilog - Coert Vonk\" \/>\n<meta property=\"og:description\" content=\"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975\" \/>\n<meta property=\"og:site_name\" content=\"Coert Vonk\" \/>\n<meta property=\"article:published_time\" content=\"2011-12-05T01:36:22+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-07T01:21:57+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png\" \/>\n\t<meta property=\"og:image:width\" content=\"300\" \/>\n\t<meta property=\"og:image:height\" content=\"300\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Coert Vonk\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"17 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebSite\",\"@id\":\"https:\/\/coert.vonk.one\/#website\",\"url\":\"https:\/\/coert.vonk.one\/\",\"name\":\"Coert Vonk\",\"description\":\"Embedded Software Engineer\",\"publisher\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/coert.vonk.one\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png\",\"contentUrl\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png\",\"width\":300,\"height\":300},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage\",\"url\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975\",\"name\":\"Implementation of the LC-3 instruction set in Verilog - Coert Vonk\",\"isPartOf\":{\"@id\":\"https:\/\/coert.vonk.one\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage\"},\"datePublished\":\"2011-12-05T01:36:22+00:00\",\"dateModified\":\"2022-02-07T01:21:57+00:00\",\"description\":\"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.\",\"breadcrumb\":{\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Vonk Family\",\"item\":\"https:\/\/coert.vonk.one\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Inquiries\",\"item\":\"https:\/\/coert.vonk.one\/category\/inquiries\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"How does a CPU work?\",\"item\":\"https:\/\/coert.vonk.one\/category\/inquiries\/how-cpu-work\"},{\"@type\":\"ListItem\",\"position\":4,\"name\":\"Implementation\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#article\",\"isPartOf\":{\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage\"},\"author\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"headline\":\"Implementation\",\"datePublished\":\"2011-12-05T01:36:22+00:00\",\"dateModified\":\"2022-02-07T01:21:57+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage\"},\"wordCount\":3313,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\"},\"image\":{\"@id\":\"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage\"},\"thumbnailUrl\":\"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png\",\"articleSection\":[\"How does a CPU work?\"],\"inLanguage\":\"en-US\"},{\"@type\":[\"Person\",\"Organization\"],\"@id\":\"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e\",\"name\":\"Coert Vonk\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/coert.vonk.one\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"contentUrl\":\"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g\",\"caption\":\"Coert Vonk\"},\"logo\":{\"@id\":\"https:\/\/coert.vonk.one\/#personlogo\"},\"description\":\"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.\",\"sameAs\":[\"https:\/\/coert.vonk.one\"],\"url\":\"/\/author\/cvonk\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Implementation of the LC-3 instruction set in Verilog - Coert Vonk","description":"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975","og_locale":"en_US","og_type":"article","og_title":"Implementation of the LC-3 instruction set in Verilog - Coert Vonk","og_description":"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.","og_url":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975","og_site_name":"Coert Vonk","article_published_time":"2011-12-05T01:36:22+00:00","article_modified_time":"2022-02-07T01:21:57+00:00","og_image":[{"width":300,"height":300,"url":"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png","type":"image\/png"}],"twitter_card":"summary","twitter_misc":{"Written by":"Coert Vonk","Est. reading time":"17 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebSite","@id":"https:\/\/coert.vonk.one\/#website","url":"https:\/\/coert.vonk.one\/","name":"Coert Vonk","description":"Embedded Software Engineer","publisher":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/coert.vonk.one\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage","inLanguage":"en-US","url":"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png","contentUrl":"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png","width":300,"height":300},{"@type":"WebPage","@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage","url":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975","name":"Implementation of the LC-3 instruction set in Verilog - Coert Vonk","isPartOf":{"@id":"https:\/\/coert.vonk.one\/#website"},"primaryImageOfPage":{"@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage"},"datePublished":"2011-12-05T01:36:22+00:00","dateModified":"2022-02-07T01:21:57+00:00","description":"Shows an implementation of the LC-3 instruction set in Verilog HDL. Includes test benches and simulation results.","breadcrumb":{"@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Vonk Family","item":"https:\/\/coert.vonk.one\/"},{"@type":"ListItem","position":2,"name":"Inquiries","item":"https:\/\/coert.vonk.one\/category\/inquiries"},{"@type":"ListItem","position":3,"name":"How does a CPU work?","item":"https:\/\/coert.vonk.one\/category\/inquiries\/how-cpu-work"},{"@type":"ListItem","position":4,"name":"Implementation"}]},{"@type":"Article","@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#article","isPartOf":{"@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage"},"author":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"headline":"Implementation","datePublished":"2011-12-05T01:36:22+00:00","dateModified":"2022-02-07T01:21:57+00:00","mainEntityOfPage":{"@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#webpage"},"wordCount":3313,"commentCount":0,"publisher":{"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e"},"image":{"@id":"https:\/\/coert.vonk.one\/inquiries\/how-cpu-work\/implementation-30975#primaryimage"},"thumbnailUrl":"https:\/\/coert.vonk.one\/wp-content\/uploads\/school-microprocessor.png","articleSection":["How does a CPU work?"],"inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"https:\/\/coert.vonk.one\/#\/schema\/person\/5eeda746b43b88312a0621fdc226c70e","name":"Coert Vonk","image":{"@type":"ImageObject","@id":"https:\/\/coert.vonk.one\/#personlogo","inLanguage":"en-US","url":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","contentUrl":"http:\/\/1.gravatar.com\/avatar\/193315b96c6661985694e2ecd91f2996?s=96&d=mm&r=g","caption":"Coert Vonk"},"logo":{"@id":"https:\/\/coert.vonk.one\/#personlogo"},"description":"Passionately curious and stubbornly persistent. Enjoys to inspire and consult with others to exchange the poetry of logical ideas.","sameAs":["https:\/\/coert.vonk.one"],"url":"/\/author\/cvonk"}]}},"_links":{"self":[{"href":"/\/wp-json\/wp\/v2\/posts\/30975"}],"collection":[{"href":"/\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"/\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"/\/wp-json\/wp\/v2\/users\/41"}],"replies":[{"embeddable":true,"href":"/\/wp-json\/wp\/v2\/comments?post=30975"}],"version-history":[{"count":7,"href":"/\/wp-json\/wp\/v2\/posts\/30975\/revisions"}],"predecessor-version":[{"id":31120,"href":"/\/wp-json\/wp\/v2\/posts\/30975\/revisions\/31120"}],"wp:featuredmedia":[{"embeddable":true,"href":"/\/wp-json\/wp\/v2\/media\/6678"}],"wp:attachment":[{"href":"/\/wp-json\/wp\/v2\/media?parent=30975"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"/\/wp-json\/wp\/v2\/categories?post=30975"},{"taxonomy":"post_tag","embeddable":true,"href":"/\/wp-json\/wp\/v2\/tags?post=30975"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}